<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Browser Agent Sandbox</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background: #1a1a1a;
      color: #e0e0e0;
    }
    h1 {
      color: #fff;
    }
    .config-section {
      background: #2a2a2a;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    input[type="password"], input[type="text"], textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #333;
      color: #fff;
      font-size: 14px;
      margin-bottom: 10px;
    }
    button {
      background: #4a9eff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background: #3a8eef;
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    .chat-section {
      background: #2a2a2a;
      border-radius: 8px;
      overflow: hidden;
    }
    .messages {
      height: 400px;
      overflow-y: auto;
      padding: 20px;
      border-bottom: 1px solid #444;
    }
    .message {
      margin-bottom: 15px;
      padding: 10px 15px;
      border-radius: 8px;
    }
    .message.user {
      background: #3a5a8a;
      margin-left: 20%;
    }
    .message.assistant {
      background: #3a3a3a;
      margin-right: 20%;
    }
    .message.error {
      background: #5a3a3a;
      color: #ff8080;
    }
    .message pre {
      background: #222;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 10px 0;
    }
    .input-area {
      display: flex;
      padding: 15px;
      gap: 10px;
    }
    .input-area input {
      flex: 1;
      margin-bottom: 0;
    }
    .status {
      padding: 10px;
      text-align: center;
      font-size: 12px;
      color: #888;
    }
    .tool-call {
      background: #2a3a4a;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      font-size: 13px;
    }
    .tool-call .name {
      font-weight: bold;
      color: #4a9eff;
    }
    .tool-call .running {
      color: #888;
      font-style: italic;
    }
    .message.streaming .cursor {
      animation: blink 1s step-end infinite;
      color: #4a9eff;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }
  </style>
</head>
<body>
  <h1>Browser Agent Sandbox</h1>

  <div class="config-section">
    <label for="apiKey">OpenRouter API Key</label>
    <input type="password" id="apiKey" placeholder="sk-or-..." />
    <button onclick="saveApiKey()">Save Key</button>
    <span id="keyStatus"></span>
  </div>

  <div class="chat-section">
    <div class="messages" id="messages"></div>
    <div class="status" id="status">Ready</div>
    <div class="input-area">
      <input type="text" id="input" placeholder="Type a message..." onkeypress="handleKeyPress(event)" />
      <button id="sendBtn" onclick="sendMessage()">Send</button>
    </div>
  </div>

  <script type="module">
    import {
      setStoredConfig,
      getStoredConfig,
      runAgent,
      generateId,
      createToolRegistry,
      ALL_TOOLS,
      parseModelString,
      // Agent utilities
      defaultAgent,
      agents,
      getAgent,
    } from '../index.ts';

    // Make available globally for onclick handlers
    window.agentModule = {
      setStoredConfig,
      getStoredConfig,
      runAgent,
      generateId,
      createToolRegistry,
      ALL_TOOLS,
      parseModelString,
      // Agents
      defaultAgent,
      agents,
      getAgent,
    };

    // Log agent info
    console.log('Default agent:', defaultAgent.description, '- model:', defaultAgent.model);
    console.log('Available agents:', Object.keys(agents));

    // Check for existing key
    const existingConfig = getStoredConfig();
    if (existingConfig) {
      document.getElementById('keyStatus').textContent = ' ✓ Key saved';
      document.getElementById('apiKey').value = '••••••••••••••••';
    }

    // Simple mock database for testing
    window.mockDb = {
      data: {
        users: [
          { id: 1, name: 'Alice', email: 'alice@example.com' },
          { id: 2, name: 'Bob', email: 'bob@example.com' },
        ],
        products: [
          { id: 1, name: 'Widget', price: 9.99 },
          { id: 2, name: 'Gadget', price: 19.99 },
        ],
      },
      query(sql) {
        console.log('SQL Query:', sql);
        // Simple mock query handling
        const upperSql = sql.toUpperCase();
        if (upperSql.includes('FROM USERS')) {
          return this.data.users;
        }
        if (upperSql.includes('FROM PRODUCTS')) {
          return this.data.products;
        }
        if (upperSql.includes('PRAGMA')) {
          return [];
        }
        return [];
      },
      execute(sql) {
        console.log('SQL Execute:', sql);
      },
      getSchema() {
        return [
          {
            table_name: 'users',
            columns: [
              { name: 'id', type: 'INTEGER', nullable: false },
              { name: 'name', type: 'TEXT', nullable: false },
              { name: 'email', type: 'TEXT', nullable: true },
            ],
          },
          {
            table_name: 'products',
            columns: [
              { name: 'id', type: 'INTEGER', nullable: false },
              { name: 'name', type: 'TEXT', nullable: false },
              { name: 'price', type: 'REAL', nullable: false },
            ],
          },
        ];
      },
      notifyChange() {},
      async getPages() {
        return [{ path: 'index.mdx', title: 'Home' }];
      },
      async getPage(path) {
        return { content: '# Test Page\n\nHello world!', title: 'Test' };
      },
      async savePage() {},
    };

    // Message history
    window.messages = [];
    window.session = null;
  </script>

  <script>
    function saveApiKey() {
      const apiKey = document.getElementById('apiKey').value;
      if (apiKey && !apiKey.startsWith('••')) {
        window.agentModule.setStoredConfig({ type: 'openrouter', apiKey });
        document.getElementById('keyStatus').textContent = ' ✓ Key saved';
        document.getElementById('apiKey').value = '••••••••••••••••';
      }
    }

    function handleKeyPress(event) {
      if (event.key === 'Enter') {
        sendMessage();
      }
    }

    function addMessage(role, content, isError = false) {
      const messagesEl = document.getElementById('messages');
      const msgEl = document.createElement('div');
      msgEl.className = `message ${role}${isError ? ' error' : ''}`;
      msgEl.innerHTML = content;
      messagesEl.appendChild(msgEl);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function setStatus(text) {
      document.getElementById('status').textContent = text;
    }

    async function sendMessage() {
      const input = document.getElementById('input');
      const sendBtn = document.getElementById('sendBtn');
      const messageText = input.value.trim();

      if (!messageText) return;

      const config = window.agentModule.getStoredConfig();
      if (!config) {
        addMessage('error', 'Please add your OpenRouter API key first', true);
        return;
      }

      // Use the default agent (hands - primary user-facing agent)
      const selectedAgent = window.agentModule.defaultAgent;
      const parsed = window.agentModule.parseModelString(selectedAgent.model);

      // Create session if needed
      if (!window.session) {
        window.session = {
          id: window.agentModule.generateId('session'),
          time: { created: Date.now(), updated: Date.now() },
          agent: 'hands',
          model: { providerId: parsed.gateway, modelId: parsed.openRouterModelId },
        };
      }

      // Add user message
      const userMsgId = window.agentModule.generateId('msg');
      const userMessage = {
        info: {
          id: userMsgId,
          sessionId: window.session.id,
          role: 'user',
          time: { created: Date.now() },
        },
        parts: [{
          id: window.agentModule.generateId('part'),
          sessionId: window.session.id,
          messageId: userMsgId,
          type: 'text',
          text: messageText,
        }],
      };
      window.messages.push(userMessage);
      addMessage('user', escapeHtml(messageText));

      input.value = '';
      sendBtn.disabled = true;
      setStatus(`Thinking (${parsed.provider}/${parsed.model})...`);

      try {
        const toolContext = { db: window.mockDb };

        // Use the real agent config - it will parse the model string automatically
        const { events, abort } = window.agentModule.runAgent({
          session: window.session,
          messages: window.messages,
          agent: selectedAgent,  // Real agent config from agents/
          toolContext,
          // Only enable tools we have implementations for in browser
          enabledTools: ['sql', 'schema', 'code'],
        });

        let assistantContent = '';
        const toolCalls = [];
        let streamingMsgEl = null;

        // Create streaming message element
        function updateStreamingMessage() {
          if (!streamingMsgEl) {
            streamingMsgEl = document.createElement('div');
            streamingMsgEl.className = 'message assistant streaming';
            document.getElementById('messages').appendChild(streamingMsgEl);
          }

          let html = '';

          // Add tool calls
          for (const tool of toolCalls) {
            html += `<div class="tool-call">
              <span class="name">${tool.tool}</span>
              <pre>${escapeHtml(JSON.stringify(tool.state.input, null, 2))}</pre>
              ${tool.state.status === 'completed'
                ? `<pre>${escapeHtml(typeof tool.state.output === 'string' ? tool.state.output : JSON.stringify(tool.state.output, null, 2))}</pre>`
                : '<span class="running">Running...</span>'}
            </div>`;
          }

          // Add streaming text
          if (assistantContent) {
            html += formatMarkdown(assistantContent);
            html += '<span class="cursor">▊</span>';
          }

          streamingMsgEl.innerHTML = html;
          const messagesEl = document.getElementById('messages');
          messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        for await (const event of events) {
          switch (event.type) {
            case 'step.started':
              setStatus('Generating response...');
              break;

            case 'part.created':
              if (event.part.type === 'text') {
                assistantContent = event.part.text;
                updateStreamingMessage();
              } else if (event.part.type === 'tool') {
                toolCalls.push(event.part);
                setStatus(`Running tool: ${event.part.tool}...`);
                updateStreamingMessage();
              }
              break;

            case 'part.updated':
              if (event.part.type === 'text') {
                assistantContent = event.part.text;
                updateStreamingMessage();
              } else if (event.part.type === 'tool') {
                const idx = toolCalls.findIndex(t => t.id === event.part.id);
                if (idx >= 0) toolCalls[idx] = event.part;
                updateStreamingMessage();
              }
              break;

            case 'step.finished':
              setStatus('Processing...');
              break;

            case 'error':
              addMessage('error', `Error: ${event.error.message}`, true);
              break;

            case 'done':
              // Store assistant message for multi-turn conversations
              const assistantMsgId = window.agentModule.generateId('msg');
              const assistantParts = [];

              // Add text part if present
              if (assistantContent) {
                assistantParts.push({
                  id: window.agentModule.generateId('part'),
                  sessionId: window.session.id,
                  messageId: assistantMsgId,
                  type: 'text',
                  text: assistantContent,
                });
              }

              // Add tool parts
              for (const tool of toolCalls) {
                assistantParts.push(tool);
              }

              // Store in messages array for next turn
              window.messages.push({
                info: {
                  id: assistantMsgId,
                  sessionId: window.session.id,
                  role: 'assistant',
                  parentId: userMsgId,
                  time: { created: Date.now() },
                },
                parts: assistantParts,
              });

              // Finalize streaming message (remove cursor)
              if (streamingMsgEl) {
                streamingMsgEl.classList.remove('streaming');
                let html = '';

                for (const tool of toolCalls) {
                  html += `<div class="tool-call">
                    <span class="name">${tool.tool}</span>
                    <pre>${escapeHtml(JSON.stringify(tool.state.input, null, 2))}</pre>
                    ${tool.state.status === 'completed'
                      ? `<pre>${escapeHtml(typeof tool.state.output === 'string' ? tool.state.output : JSON.stringify(tool.state.output, null, 2))}</pre>`
                      : ''}
                  </div>`;
                }

                if (assistantContent) {
                  html += formatMarkdown(assistantContent);
                }

                streamingMsgEl.innerHTML = html;
              }
              break;
          }
        }
      } catch (err) {
        addMessage('error', `Error: ${err.message}`, true);
      } finally {
        sendBtn.disabled = false;
        setStatus('Ready');
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatMarkdown(text) {
      // Simple markdown formatting
      return text
        .replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/\n/g, '<br>');
    }
  </script>
</body>
</html>
