/**
 * Hands Database Module
 *
 * Provides typed SQL access via Kysely + Durable Object SQLite.
 * - Blocks: read-only access (SELECT only)
 * - Actions: full read-write access
 *
 * Types are generated by vite-plugin-db-types from the actual database schema.
 * Import the DB type from "@hands/db/types" for typed queries.
 */

import { AsyncLocalStorage } from "node:async_hooks";
import { env } from "cloudflare:workers";
import { sql as kyselySql, type Kysely } from "kysely";
import { createDb } from "rwsdk/db";

// Re-export Database DO for worker.tsx
export { Database } from "./Database";

// Import the generated DB type (will be available after first dev server run)
import type { DB } from "@hands/db/types";

// Re-export for consumers
export type { DB };

// Context for tracking if we're in a block (read-only) or action (read-write)
type DbMode = "block" | "action";

// Use AsyncLocalStorage for per-request mode tracking
const dbModeStorage = new AsyncLocalStorage<DbMode>();

// Lazy-initialized Kysely instance
let kyselyInstance: Kysely<DB> | null = null;

/**
 * Get or create the Kysely database instance
 */
function getOrCreateDb(): Kysely<DB> {
  if (!kyselyInstance) {
    // @ts-expect-error - DATABASE binding is defined in wrangler.jsonc
    const databaseBinding = env.DATABASE as DurableObjectNamespace;
    if (!databaseBinding) {
      throw new Error("[db] DATABASE binding not found. Check wrangler.jsonc durable_objects config.");
    }
    kyselyInstance = createDb<DB>(databaseBinding, "hands-db");
  }
  return kyselyInstance!;
}

/**
 * Run a function with a specific database mode.
 * - "block": read-only (SELECT only)
 * - "action": read-write (all SQL)
 */
export function runWithDbMode<T>(mode: DbMode, fn: () => T): T {
  return dbModeStorage.run(mode, fn);
}

/**
 * Get the current database mode (defaults to "block" if not set)
 */
function getCurrentMode(): DbMode {
  return dbModeStorage.getStore() ?? "block";
}

/**
 * Check if a SQL statement is read-only (SELECT)
 */
function isReadOnlyQuery(query: string): boolean {
  const trimmed = query.trim().toUpperCase();
  return (
    trimmed.startsWith("SELECT") ||
    trimmed.startsWith("WITH") || // CTEs that start with WITH are typically SELECT
    trimmed.startsWith("EXPLAIN") ||
    trimmed.startsWith("PRAGMA")
  );
}

/**
 * Get the Kysely instance (lazy init)
 */
function getKysely(): Kysely<DB> {
  return getOrCreateDb();
}

/**
 * Tagged template for raw SQL queries
 * Enforces read-only in block mode
 *
 * Usage:
 *   const users = await sql<User>`SELECT * FROM users WHERE id = ${userId}`;
 */
export async function sql<T = Record<string, unknown>>(
  strings: TemplateStringsArray,
  ...values: unknown[]
): Promise<T[]> {
  const db = getKysely();

  // Build the query string to check if it's read-only
  let queryText = strings[0];
  for (let i = 0; i < values.length; i++) {
    queryText += `?${strings[i + 1]}`;
  }

  // Enforce read-only in block mode
  const mode = getCurrentMode();
  if (mode === "block" && !isReadOnlyQuery(queryText)) {
    throw new Error(
      "[db] Write operations are not allowed in blocks. Use an action instead."
    );
  }

  // Use Kysely's sql template to build the query
  const rawQuery = kyselySql<T>(strings, ...values);
  const result = await rawQuery.execute(db);

  return result.rows as T[];
}

/**
 * Get the typed Kysely instance for complex queries
 * Note: Does NOT enforce read-only - use with caution in blocks
 */
export function getDb(): Kysely<DB> {
  return getKysely();
}

/**
 * Re-export Kysely's sql helper for building raw SQL fragments
 */
export { kyselySql };
