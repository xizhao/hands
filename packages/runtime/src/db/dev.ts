/**
 * Hands Database Module
 *
 * Provides typed SQL access via Kysely + D1.
 * - Blocks: read-only access (SELECT only)
 * - Actions: full read-write access
 *
 * Types are generated by vite-plugin-db-types from the actual database schema.
 * Import the DB type from "@hands/db/types" for typed queries.
 */

import { env } from "cloudflare:workers";
import { AsyncLocalStorage } from "node:async_hooks";
import { Kysely, sql as kyselySql } from "kysely";
import { D1Dialect } from "kysely-d1";

// Import the generated DB type (will be available after first dev server run)
import type { DB } from "@hands/db/types";

// Re-export for consumers
export type { DB };

// Context for tracking if we're in a block (read-only) or action (read-write)
type DbMode = "block" | "action";

// Use AsyncLocalStorage for per-request mode tracking
const dbModeStorage = new AsyncLocalStorage<DbMode>();

// Lazy-initialized Kysely instance
let kyselyInstance: Kysely<DB> | null = null;

/**
 * Get or create the Kysely database instance
 */
function getOrCreateDb(): Kysely<DB> {
  if (!kyselyInstance) {
    const d1Database = env.DB as D1Database;
    if (!d1Database) {
      throw new Error(
        "[db] DB binding not found. Check wrangler.jsonc d1_databases config.",
      );
    }
    kyselyInstance = new Kysely<DB>({
      dialect: new D1Dialect({ database: d1Database }),
    });
  }
  return kyselyInstance!;
}

/**
 * Run a function with a specific database mode.
 * - "block": read-only (SELECT only)
 * - "action": read-write (all SQL)
 */
export function runWithDbMode<T>(mode: DbMode, fn: () => T): T {
  return dbModeStorage.run(mode, fn);
}

/**
 * Get the current database mode (defaults to "block" if not set)
 */
function getCurrentMode(): DbMode {
  return dbModeStorage.getStore() ?? "block";
}

/**
 * Check if a SQL statement is read-only (SELECT)
 */
function isReadOnlyQuery(query: string): boolean {
  const trimmed = query.trim().toUpperCase();
  return (
    trimmed.startsWith("SELECT") ||
    trimmed.startsWith("WITH") || // CTEs that start with WITH are typically SELECT
    trimmed.startsWith("EXPLAIN") ||
    trimmed.startsWith("PRAGMA")
  );
}

/**
 * Get the Kysely instance (lazy init)
 */
function getKysely(): Kysely<DB> {
  return getOrCreateDb();
}

/**
 * Tagged template for raw SQL queries
 * Enforces read-only in block mode
 *
 * Usage:
 *   const users = await sql<User>`SELECT * FROM users WHERE id = ${userId}`;
 */
export async function sql<T = Record<string, unknown>>(
  strings: TemplateStringsArray,
  ...values: unknown[]
): Promise<T[]> {
  const db = getKysely();

  // Build the query string to check if it's read-only
  let queryText = strings[0];
  for (let i = 0; i < values.length; i++) {
    queryText += `?${strings[i + 1]}`;
  }

  // Enforce read-only in block mode
  const mode = getCurrentMode();
  if (mode === "block" && !isReadOnlyQuery(queryText)) {
    throw new Error("[db] Write operations are not allowed in blocks. Use an action instead.");
  }

  // Use Kysely's sql template to build the query
  const rawQuery = kyselySql<T>(strings, ...values);
  const result = await rawQuery.execute(db);

  return result.rows as T[];
}

/**
 * Get the typed Kysely instance for complex queries
 * Note: Does NOT enforce read-only - use with caution in blocks
 */
export function getDb(): Kysely<DB> {
  return getKysely();
}

/**
 * Get all user tables from sqlite_master.
 * Excludes sqlite internal tables and tables starting with __ (migrations, etc.)
 *
 * Note: Uses GLOB instead of LIKE because _ is a wildcard in LIKE.
 */
export async function getUserTables(): Promise<Array<{ name: string; sql: string }>> {
  const db = getKysely();
  const result = await kyselySql<{ name: string; sql: string }>`
    SELECT name, sql FROM sqlite_master
    WHERE type = 'table'
      AND name NOT LIKE 'sqlite_%'
      AND name NOT GLOB '__*'
    ORDER BY name
  `.execute(db);
  return result.rows;
}

/**
 * Re-export Kysely's sql helper for building raw SQL fragments
 */
export { kyselySql };
