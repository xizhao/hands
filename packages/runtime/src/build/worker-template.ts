/**
 * Worker template generator for RedwoodSDK projects
 *
 * Generates a complete worker.tsx that includes:
 * - RSC block rendering (Flight wire format)
 * - Postgres routes (/postgres/*)
 * - Workbook routes (/workbook/*)
 * - Eval routes (/eval/*)
 * - Sync routes (/sync/*)
 * - Health/status routes
 *
 * This is the "all-in-one" worker that handles everything.
 */

import type { HandsConfig } from "./index.js"

export interface WorkerTemplateConfig {
  config: HandsConfig
  blocks: Array<{ id: string; path: string }>
  workbookDir: string
}

/**
 * Generate the complete worker.tsx content
 */
export function generateWorkerTemplate(opts: WorkerTemplateConfig): string {
  const { config, blocks, workbookDir } = opts
  const blocksDir = config.blocks?.dir || "./blocks"

  // Generate block imports
  const blockImports = blocks
    .map((block, i) => {
      const importPath = `../../${blocksDir}/${block.path}`
      return `import Block${i} from "${importPath}";`
    })
    .join("\n")

  // Generate block registry
  const blockRegistry = blocks.map((block, i) => `  "${block.id}": Block${i},`).join("\n")

  return `// Generated by hands RSC build system
// Regenerate with: hands build --rsc
// All-in-one worker with RSC blocks + API routes

import { Hono } from "hono";
import { cors } from "hono/cors";
import * as React from "react";
import { renderToReadableStream } from "react-server-dom-webpack/server.edge";
import { existsSync } from "node:fs";
import { readFile, writeFile, readdir, mkdir } from "node:fs/promises";
import { join } from "node:path";

${blockImports}

// Types
type Bindings = {
  ENVIRONMENT: string;
  WORKBOOK_ID: string;
  WORKBOOK_DIR: string;
  RUNTIME_PORT: string;
};

type Variables = {
  db: ReturnType<typeof createDbProxy>;
  workbookDir: string;
  workbookId: string;
  runtimePort: number;
};

// Block registry
const BLOCKS: Record<string, React.FC<any>> = {
${blockRegistry}
};

// Create Hono app
const app = new Hono<{ Bindings: Bindings; Variables: Variables }>();

// === Middleware ===

// CORS
app.use("/*", cors());

// Initialize context
app.use("/*", async (c, next) => {
  const runtimePort = parseInt(c.env.RUNTIME_PORT || "55000", 10);
  const db = createDbProxy(runtimePort);
  c.set("db", db);
  c.set("runtimePort", runtimePort);
  c.set("workbookDir", c.env.WORKBOOK_DIR || "${workbookDir}");
  c.set("workbookId", c.env.WORKBOOK_ID || "${config.name || "workbook"}");
  await next();
});

// === Health/Status Routes ===

app.get("/health", (c) => {
  return c.json({
    status: "ok",
    name: "${config.name || "workbook"}",
    rsc: true,
    healthy: true,
  });
});

app.get("/status", (c) => {
  return c.json({
    workbookId: c.get("workbookId"),
    workbookDir: c.get("workbookDir"),
    rsc: true,
    runtimePort: c.get("runtimePort"),
  });
});

// === Block Routes (RSC) ===

app.get("/blocks", (c) => {
  return c.json({
    blocks: Object.keys(BLOCKS),
    format: "flight",
  });
});

app.get("/blocks/:blockId", async (c) => {
  const blockId = c.req.param("blockId");
  const Block = BLOCKS[blockId];

  if (!Block) {
    return c.json({ error: \`Block not found: \${blockId}\` }, 404);
  }

  const props = Object.fromEntries(new URL(c.req.url).searchParams);
  const db = c.get("db");
  const ctx = {
    db,
    sql: db.sql,
    params: props,
    env: c.env,
  };

  try {
    const stream = renderToReadableStream(
      React.createElement(Block, { ...props, ctx })
    );

    return new Response(stream, {
      headers: {
        "Content-Type": "text/x-component",
        "Cache-Control": "no-cache",
      },
    });
  } catch (err) {
    const error = err instanceof Error ? err.message : String(err);
    return c.json({ error }, 500);
  }
});

app.post("/blocks/:blockId/rsc", async (c) => {
  const blockId = c.req.param("blockId");
  const Block = BLOCKS[blockId];

  if (!Block) {
    return c.json({ error: \`Block not found: \${blockId}\` }, 404);
  }

  const props = await c.req.json();
  const db = c.get("db");
  const ctx = {
    db,
    sql: db.sql,
    params: props,
    env: c.env,
  };

  try {
    const stream = renderToReadableStream(
      React.createElement(Block, { ...props, ctx })
    );

    return new Response(stream, {
      headers: {
        "Content-Type": "text/x-component",
        "Cache-Control": "no-cache",
      },
    });
  } catch (err) {
    const error = err instanceof Error ? err.message : String(err);
    return c.json({ error }, 500);
  }
});

// === RSC Component Routes ===
// Render arbitrary JSX components via RSC for the visual editor

// Component registry - dynamically loaded from stdlib and user imports
const COMPONENTS: Record<string, React.FC<any>> = {};

// Register stdlib components
async function registerStdlibComponents() {
  try {
    const stdlib = await import("@hands/stdlib");
    if (stdlib.Button) COMPONENTS["Button"] = stdlib.Button;
    if (stdlib.Card) COMPONENTS["Card"] = stdlib.Card;
    if (stdlib.CardHeader) COMPONENTS["CardHeader"] = stdlib.CardHeader;
    if (stdlib.CardTitle) COMPONENTS["CardTitle"] = stdlib.CardTitle;
    if (stdlib.CardDescription) COMPONENTS["CardDescription"] = stdlib.CardDescription;
    if (stdlib.CardContent) COMPONENTS["CardContent"] = stdlib.CardContent;
    if (stdlib.Badge) COMPONENTS["Badge"] = stdlib.Badge;
    if (stdlib.MetricCard) COMPONENTS["MetricCard"] = stdlib.MetricCard;
    // Add more as needed
  } catch {
    // stdlib not available
  }
}

// Initialize on startup
registerStdlibComponents();

app.post("/rsc/component", async (c) => {
  const { tagName, props = {}, children, elementId } = await c.req.json<{
    tagName: string;
    props?: Record<string, unknown>;
    children?: string;
    elementId?: string;
  }>();

  if (!tagName) {
    return c.json({ error: "tagName is required" }, 400);
  }

  // Look up component in registry
  const Component = COMPONENTS[tagName];

  if (!Component) {
    // Component not found - return a placeholder element
    // The editor will show this as "unknown component"
    return c.json({
      error: \`Component not found: \${tagName}. Available: \${Object.keys(COMPONENTS).join(", ")}\`
    }, 404);
  }

  try {
    // Build the element with props
    const element = React.createElement(Component, {
      ...props,
      key: elementId,
    });

    const stream = renderToReadableStream(element);

    return new Response(stream, {
      headers: {
        "Content-Type": "text/x-component",
        "Cache-Control": "no-cache",
      },
    });
  } catch (err) {
    const error = err instanceof Error ? err.message : String(err);
    console.error(\`[rsc] Component render error (\${tagName}):\`, error);
    return c.json({ error }, 500);
  }
});

// List available RSC components
app.get("/rsc/components", (c) => {
  return c.json({
    components: Object.keys(COMPONENTS),
    count: Object.keys(COMPONENTS).length,
  });
});

// === Workbook Routes ===
// Note: Postgres/DB routes are handled by runtime on RUNTIME_PORT

app.get("/workbook/manifest", async (c) => {
  const workbookDir = c.get("workbookDir");
  const workbookId = c.get("workbookId");
  const db = c.get("db");

  try {
    const manifest = await buildManifest(workbookDir, workbookId, db);
    return c.json(manifest);
  } catch (err) {
    return c.json({ error: String(err) }, 500);
  }
});

app.get("/workbook/pages/:pageId", async (c) => {
  const workbookDir = c.get("workbookDir");
  const pageId = c.req.param("pageId");

  try {
    const content = await getPageContent(workbookDir, pageId);
    return c.json({ success: true, pageId, content });
  } catch (err) {
    return c.json({ error: String(err) }, 404);
  }
});

app.put("/workbook/pages/:pageId", async (c) => {
  const workbookDir = c.get("workbookDir");
  const pageId = c.req.param("pageId");
  const { content } = await c.req.json<{ content: string }>();

  try {
    await savePageContent(workbookDir, pageId, content);
    return c.json({ success: true, pageId });
  } catch (err) {
    return c.json({ error: String(err) }, 500);
  }
});

app.post("/workbook/pages/create", async (c) => {
  const workbookDir = c.get("workbookDir");
  const { title } = await c.req.json<{ title?: string }>();

  try {
    const page = await createPage(workbookDir, title || "Untitled");
    return c.json({ success: true, page });
  } catch (err) {
    return c.json({ error: String(err) }, 500);
  }
});

// 404 fallback
app.all("*", (c) => c.notFound());

export default app;

// === Helpers ===

// DB proxy that forwards queries to the runtime's PGlite instance
function createDbProxy(runtimePort: number) {
  const baseUrl = \`http://localhost:\${runtimePort}\`;

  const query = async (sql: string, params?: unknown[]) => {
    const response = await fetch(\`\${baseUrl}/db/query\`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ query: sql, params }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "Database query failed");
    }

    const result = await response.json();
    return result.rows;
  };

  // Tagged template literal for SQL queries
  const sql = async <T = Record<string, unknown>>(
    strings: TemplateStringsArray,
    ...values: unknown[]
  ): Promise<T[]> => {
    // Build parameterized query: "SELECT * FROM users WHERE id = $1"
    let queryText = strings[0];
    const params: unknown[] = [];

    for (let i = 0; i < values.length; i++) {
      params.push(values[i]);
      queryText += \`$\${i + 1}\` + strings[i + 1];
    }

    return query(queryText, params) as Promise<T[]>;
  };

  return {
    query,
    sql,
    tables: async () => {
      const response = await fetch(\`\${baseUrl}/db/tables\`);
      if (!response.ok) {
        throw new Error("Failed to fetch tables");
      }
      return response.json();
    },
  };
}

async function buildManifest(workbookDir: string, workbookId: string, db: any) {
  // Discover pages
  const pagesDir = join(workbookDir, "pages");
  let pages: any[] = [];
  try {
    const files = await readdir(pagesDir);
    for (const file of files) {
      if (file.endsWith(".md") || file.endsWith(".mdx")) {
        const content = await readFile(join(pagesDir, file), "utf-8");
        const title = extractTitle(content) || file.replace(/\\.(mdx?|md)$/, "");
        const id = file.replace(/\\.(mdx?|md)$/, "");
        pages.push({
          id,
          route: \`/\${id}\`,
          title,
          path: file,
        });
      }
    }
  } catch {
    // No pages directory
  }

  // Get blocks from registry
  const blocks = Object.keys(BLOCKS).map(id => ({
    id,
    title: id,
    path: id,
  }));

  // Get tables from runtime via proxy
  let tables: string[] = [];
  try {
    const tablesResult = await db.tables();
    tables = tablesResult.map((r: any) => r.name || r.table_name);
  } catch {
    // DB not available yet (still booting)
  }

  // Read sources from hands.json
  const sources: any[] = [];
  try {
    const handsJson = await readFile(join(workbookDir, "hands.json"), "utf-8");
    const config = JSON.parse(handsJson);
    if (config.sources) {
      for (const [name, sc] of Object.entries(config.sources)) {
        sources.push({
          name,
          enabled: (sc as any).enabled !== false,
          schedule: (sc as any).schedule,
        });
      }
    }
  } catch {
    // No hands.json
  }

  const isEmpty = pages.length === 0 && blocks.length === 0 && sources.length === 0 && tables.length === 0;

  return {
    workbookId,
    workbookDir,
    pages,
    blocks,
    sources,
    tables,
    isEmpty,
  };
}

function extractTitle(content: string): string | null {
  // Try frontmatter
  const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);
  if (frontmatterMatch) {
    const titleMatch = frontmatterMatch[1].match(/title:\\s*["']?([^"'\\n]+)["']?/);
    if (titleMatch) return titleMatch[1];
  }
  // Try first heading
  const headingMatch = content.match(/^#\\s+(.+)$/m);
  if (headingMatch) return headingMatch[1];
  return null;
}

async function getPageContent(workbookDir: string, pageId: string): Promise<string> {
  const pagesDir = join(workbookDir, "pages");
  const mdxPath = join(pagesDir, \`\${pageId}.mdx\`);
  const mdPath = join(pagesDir, \`\${pageId}.md\`);

  try {
    return await readFile(mdxPath, "utf-8");
  } catch {
    return await readFile(mdPath, "utf-8");
  }
}

async function savePageContent(workbookDir: string, pageId: string, content: string): Promise<void> {
  const pagesDir = join(workbookDir, "pages");
  await mkdir(pagesDir, { recursive: true });

  const mdxPath = join(pagesDir, \`\${pageId}.mdx\`);
  await writeFile(mdxPath, content, "utf-8");
}

async function createPage(workbookDir: string, title: string) {
  const pagesDir = join(workbookDir, "pages");
  await mkdir(pagesDir, { recursive: true });

  const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "") || "untitled";
  let filename = \`\${slug}.mdx\`;
  let counter = 1;

  while (true) {
    try {
      await readFile(join(pagesDir, filename));
      filename = \`\${slug}-\${counter}.mdx\`;
      counter++;
    } catch {
      break;
    }
  }

  const content = \`---
title: "\${title}"
---

# \${title}

Start writing here...
\`;

  await writeFile(join(pagesDir, filename), content, "utf-8");

  return {
    id: filename.replace(/\\.mdx$/, ""),
    route: \`/\${filename.replace(/\\.mdx$/, "")}\`,
    title,
    path: filename,
  };
}
`
}
