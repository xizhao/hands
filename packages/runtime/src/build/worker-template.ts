/**
 * Worker template generator for RedwoodSDK projects
 *
 * Generates a complete worker.tsx that includes:
 * - RSC block rendering (Flight wire format)
 * - Postgres routes (/postgres/*)
 * - Workbook routes (/workbook/*)
 * - Eval routes (/eval/*)
 * - Sync routes (/sync/*)
 * - Health/status routes
 *
 * This is the "all-in-one" worker that handles everything.
 */

import type { HandsConfig } from "./index.js";

export interface WorkerTemplateConfig {
  config: HandsConfig;
  blocks: Array<{ id: string; path: string; parentDir: string }>;
  workbookDir: string;
}

/**
 * Generate the complete worker.tsx content
 */
export function generateWorkerTemplate(opts: WorkerTemplateConfig): string {
  const { config, blocks, workbookDir } = opts;
  const blocksDir = config.blocks?.dir || "./blocks";

  // Generate the list of known block IDs for the manifest
  const blockIds = blocks.map((b) => `"${b.id}"`).join(", ");

  return `// Generated by hands RSC build system
// Regenerate with: hands build --rsc
// All-in-one worker with RSC blocks + API routes

import { Hono } from "hono";
import { cors } from "hono/cors";
import * as React from "react";
import { renderToReadableStream } from "react-server-dom-webpack/server.edge";
import { runWithRequestInfo } from "rwsdk/worker";
import { existsSync } from "node:fs";
import { readFile, writeFile, readdir, mkdir } from "node:fs/promises";
import { join } from "node:path";
import { createTRPCClient, httpBatchLink } from "@trpc/client";
import { AsyncLocalStorage } from "node:async_hooks";

// ============================================================================
// @hands/db - Database access for server components
// ============================================================================
// Blocks import { sql } from '@hands/db' to query the database.
// The worker sets up request context before rendering via AsyncLocalStorage.
// ============================================================================

interface DbContext {
  sql<T>(strings: TemplateStringsArray, ...values: unknown[]): Promise<T[]>;
  query<TParams, TResult>(
    preparedQuery: { run(params: TParams, client: unknown): Promise<TResult[]> },
    params: TParams
  ): Promise<TResult[]>;
}

interface RequestContext {
  db: DbContext;
  params: Record<string, unknown>;
  env: Record<string, unknown>;
}

const requestContext = new AsyncLocalStorage<RequestContext>();

function runWithContext<T>(ctx: RequestContext, fn: () => T): T {
  return requestContext.run(ctx, fn);
}

function getContext(): RequestContext {
  const ctx = requestContext.getStore();
  if (!ctx) {
    throw new Error(
      "[hands] Database can only be accessed during request handling, not at module load time."
    );
  }
  return ctx;
}

/**
 * Tagged template for SQL queries
 * @example
 * import { sql } from '@hands/db'
 * const users = await sql<User>\`SELECT * FROM users WHERE active = \${true}\`
 */
export function sql<T = Record<string, unknown>>(
  strings: TemplateStringsArray,
  ...values: unknown[]
): Promise<T[]> {
  return getContext().db.sql<T>(strings, ...values);
}

/**
 * Execute a pgtyped prepared query
 * @example
 * import { query } from '@hands/db'
 * import { getUsers } from './queries.types'
 * const users = await query(getUsers, { active: true })
 */
export function query<TParams, TResult>(
  preparedQuery: { run(params: TParams, client: unknown): Promise<TResult[]> },
  params: TParams
): Promise<TResult[]> {
  return getContext().db.query(preparedQuery, params);
}

/**
 * Get URL/form params from the current request
 * @example
 * import { params } from '@hands/db'
 * const { limit = 10 } = params<{ limit?: number }>()
 */
export function params<T = Record<string, unknown>>(): T {
  return getContext().params as T;
}

/**
 * Get environment bindings
 * @example
 * import { env } from '@hands/db'
 * const { API_KEY } = env<{ API_KEY: string }>()
 */
export function env<T = Record<string, unknown>>(): T {
  return getContext().env as T;
}

// ============================================================================
// STDLIB CLIENT COMPONENTS: Pre-register for rwsdk "use client" scanning
// ============================================================================
// These imports ensure stdlib client components are included in rwsdk's
// initial directive scan. Without this, dynamically imported blocks that use
// stdlib components will fail with "No module found in module lookup" errors.
//
// Import paths use @hands/stdlib/charts/*, @hands/stdlib/ui/*, etc.
// (see stdlib's package.json exports)
// ============================================================================
import "@hands/stdlib/charts/bar-chart";
import "@hands/stdlib/charts/line-chart";
import "@hands/stdlib/maps/scatterplot-map";
import "@hands/stdlib/maps/hexagon-map";
import "@hands/stdlib/maps/heatmap-map";
import "@hands/stdlib/maps/geojson-map";
import "@hands/stdlib/ui/chart";
import "@hands/stdlib/ui/form";
import "@hands/stdlib/ui/calendar";
import "@hands/stdlib/ui/dialog";
import "@hands/stdlib/ui/dropdown-menu";
import "@hands/stdlib/ui/tooltip";
import "@hands/stdlib/ui/select";
import "@hands/stdlib/ui/sheet";
import "@hands/stdlib/ui/sidebar";
import "@hands/stdlib/ui/carousel";
import "@hands/stdlib/ui/collapsible";
import "@hands/stdlib/ui/command";
import "@hands/stdlib/ui/resizable";
import "@hands/stdlib/ui/progress";
import "@hands/stdlib/ui/input-otp";
import "@hands/stdlib/ui/label";
import "@hands/stdlib/ui/toggle-group";
import "@hands/stdlib/ui/avatar";
import "@hands/stdlib/ui/field";
import "@hands/stdlib/ui/sonner";

// ============================================================================
// ARCHITECTURE: Dynamic Block Imports
// ============================================================================
//
// Blocks are loaded dynamically via import() because:
//
// 1. rwsdk/Vite watches block files and recompiles "use client" bundles on change
// 2. Dynamic imports get the updated module from Vite's module graph
// 3. No server restart needed when blocks are added/removed/edited
// 4. Vite's HMR handles cache invalidation automatically
//
// The blocks directory is ../../${blocksDir}/ relative to worker.tsx in .hands/src/
//
// ============================================================================

// Known block IDs at build time (for manifest)
const KNOWN_BLOCK_IDS: string[] = [${blockIds}];

// Module cache for loaded blocks
const blockCache = new Map<string, React.FC<any>>();

// Error cache for blocks that failed to load (cleared on HMR)
const blockErrorCache = new Map<string, Error>();

/**
 * Dynamically load a block by ID
 * Uses Vite's module resolution which handles "use client" transforms
 * Throws on error so callers can return proper error responses
 */
async function loadBlock(blockId: string): Promise<React.FC<any>> {
  // Check error cache first (avoid repeated failed imports)
  if (blockErrorCache.has(blockId)) {
    throw blockErrorCache.get(blockId)!;
  }

  // Check success cache
  if (blockCache.has(blockId)) {
    return blockCache.get(blockId)!;
  }

  try {
    // Dynamic import - Vite resolves this and applies RSC transforms
    const mod = await import(\`../../${blocksDir}/\${blockId}.tsx\`);
    const Block = mod.default;
    if (!Block) {
      throw new Error(\`Block "\${blockId}" has no default export\`);
    }
    blockCache.set(blockId, Block);
    return Block;
  } catch (err) {
    const error = err instanceof Error ? err : new Error(String(err));
    console.error(\`[worker] Failed to load block "\${blockId}":\`, error);
    blockErrorCache.set(blockId, error);
    throw error;
  }
}

/**
 * Clear the block cache (called on HMR updates)
 */
function clearBlockCache(blockId?: string) {
  if (blockId) {
    blockCache.delete(blockId);
    blockErrorCache.delete(blockId);
  } else {
    blockCache.clear();
    blockErrorCache.clear();
  }
}

// ============================================================================
// Node ID Injection (inlined to avoid module resolution issues in Vite worker)
// ============================================================================

/**
 * Generate a stable node ID matching OXC parser format
 * Format: {tagname}_{path} where path is dot-separated indices
 */
function generateNodeId(tagName: string, path: number[]): string {
  const safeName = tagName.toLowerCase().replace(/[^a-z0-9]/g, "");
  const pathStr = path.join(".");
  return \`\${safeName}_\${pathStr}\`;
}

/**
 * Recursively traverse React elements and inject node IDs
 */
function NodeIdTraverser({
  element,
  path,
}: {
  element: React.ReactNode;
  path: number[];
}): React.ReactElement | null {
  if (element == null) return null;

  if (Array.isArray(element)) {
    return React.createElement(
      React.Fragment,
      null,
      element.map((child, idx) =>
        React.createElement(NodeIdTraverser, {
          key: idx,
          element: child,
          path: [...path.slice(0, -1), idx],
        })
      )
    );
  }

  if (typeof element === "string" || typeof element === "number" || typeof element === "boolean") {
    return React.createElement(React.Fragment, null, element);
  }

  if (React.isValidElement(element)) {
    const { type, props } = element;
    const children = (props as any).children;

    if (typeof type === "string") {
      const nodeId = generateNodeId(type, path);
      let childCounter = 0;
      const processedChildren = React.Children.map(children, (child) => {
        const childPath = [...path, childCounter++];
        return React.createElement(NodeIdTraverser, { element: child, path: childPath });
      });
      return React.cloneElement(element, { ...props, "data-node-id": nodeId } as any, processedChildren);
    }

    if (typeof type === "function") {
      let childCounter = 0;
      const processedChildren = React.Children.map(children, (child) => {
        const childPath = [...path, childCounter++];
        return React.createElement(NodeIdTraverser, { element: child, path: childPath });
      });
      return React.cloneElement(element, props, processedChildren);
    }

    let childCounter = 0;
    const processedChildren = React.Children.map(children, (child) => {
      const childPath = [...path, childCounter++];
      return React.createElement(NodeIdTraverser, { element: child, path: childPath });
    });
    return React.cloneElement(element, props, processedChildren);
  }

  return React.createElement(React.Fragment, null, element);
}

/**
 * HOC that wraps a Block component to inject node IDs
 */
function wrapWithNodeIdInjection<P extends Record<string, unknown>>(
  Block: React.ComponentType<P>,
  blockId: string
): React.ComponentType<P> {
  function WrappedBlock(props: P) {
    const element = React.createElement(Block, props);
    return React.createElement(NodeIdTraverser, { element, path: [0] });
  }
  WrappedBlock.displayName = \`WithNodeIds(\${(Block as any).displayName || (Block as any).name || blockId})\`;
  return WrappedBlock;
}

// Client manifest for RSC serialization
// This Proxy handles "use client" component references without needing webpack infrastructure
const createClientManifest = () => new Proxy({}, {
  get(_, key) {
    return { id: key, name: key, chunks: [] };
  },
});

// Create RSC request context for "use client" serialization
// rwsdk transforms add scriptsToBeLoaded tracking to client modules
function createRscRequestContext(request: Request) {
  return {
    request,
    params: {},
    ctx: {},
    cf: {},
    response: {},
    rw: {
      scriptsToBeLoaded: new Set<string>(),
      entryScripts: new Set<string>(),
      inlineScripts: new Set<string>(),
      databases: new Map(),
      nonce: "",
      rscPayload: true,
      ssr: false,
    },
  };
}

// Types
type Bindings = {
  ENVIRONMENT: string;
  WORKBOOK_ID: string;
  WORKBOOK_DIR: string;
  RUNTIME_PORT: string;
};

type Variables = {
  db: ReturnType<typeof createDbProxy>;
  workbookDir: string;
  workbookId: string;
  runtimePort: number;
};

// Static block registry - see ARCHITECTURE NOTE above for why dynamic loading isn't used

// Create Hono app
const app = new Hono<{ Bindings: Bindings; Variables: Variables }>();

// === Middleware ===

// CORS
app.use("/*", cors());

// Request logging
app.use("/*", async (c, next) => {
  const start = Date.now();
  console.log(\`[worker] → \${c.req.method} \${c.req.path}\`);
  await next();
  const ms = Date.now() - start;
  console.log(\`[worker] ← \${c.req.method} \${c.req.path} \${c.res.status} (\${ms}ms)\`);
});

// Initialize context
// Runtime port defaults to 55000 (PORTS.RUNTIME) for local dev
// In production, this would come from wrangler bindings
const DEFAULT_RUNTIME_PORT = 55000;

app.use("/*", async (c, next) => {
  const runtimePort = parseInt(c.env.RUNTIME_PORT, 10) || DEFAULT_RUNTIME_PORT;
  const db = createDbProxy(runtimePort);
  c.set("db", db);
  c.set("runtimePort", runtimePort);
  c.set("workbookDir", c.env.WORKBOOK_DIR || "${workbookDir}");
  c.set("workbookId", c.env.WORKBOOK_ID || "${config.name || "workbook"}");
  await next();
});

// === Health/Status Routes ===

app.get("/health", (c) => {
  return c.json({
    status: "ok",
    name: "${config.name || "workbook"}",
    rsc: true,
    healthy: true,
  });
});

app.get("/status", (c) => {
  return c.json({
    workbookId: c.get("workbookId"),
    workbookDir: c.get("workbookDir"),
    rsc: true,
    runtimePort: c.get("runtimePort"),
  });
});

// === Block Routes (RSC) ===
// Supports nested paths like /blocks/charts/bar-chart

app.get("/blocks", (c) => {
  return c.json({
    blocks: KNOWN_BLOCK_IDS,
    format: "flight",
  });
});

// Invalidate block cache (called by runtime on file changes)
app.post("/blocks/invalidate", async (c) => {
  const { blockId } = await c.req.json<{ blockId?: string }>();
  clearBlockCache(blockId);
  return c.json({ success: true, cleared: blockId || "all" });
});

// Use :blockId{.+} for multi-segment path matching (e.g., "charts/bar-chart")
app.get("/blocks/:blockId{.+}", async (c) => {
  const blockId = c.req.param("blockId");

  // Dynamically load the block - Vite handles "use client" transforms
  let Block: React.FC<any>;
  try {
    Block = await loadBlock(blockId);
  } catch (err) {
    // Import/load error - return the actual error, not "not found"
    const error = err instanceof Error ? err.message : String(err);
    const stack = err instanceof Error ? err.stack : undefined;
    console.error(\`[worker] Block "\${blockId}" load error:\`, err);
    return c.json({ error, stack }, 500);
  }

  const url = new URL(c.req.url);
  const props = Object.fromEntries(url.searchParams);

  // Remove internal params from props passed to component
  delete props.edit;
  delete props._ts;

  // Set up request context for db access via AsyncLocalStorage
  // Server components import { sql } from '@hands/db'
  const requestCtx = {
    db: c.get("db"),  // Uses reader role for blocks
    params: props,
    env: c.env,
  };

  try {
    // Wrap rendering with both:
    // 1. runWithContext - our AsyncLocalStorage for db access
    // 2. runWithRequestInfo - rwsdk's context for "use client" support
    const rscContext = createRscRequestContext(c.req.raw);
    const stream = runWithContext(requestCtx, () =>
      runWithRequestInfo(rscContext, () =>
        renderToReadableStream(
          React.createElement(Block, props),
          createClientManifest()
        )
      )
    );

    return new Response(stream, {
      headers: {
        "Content-Type": "text/x-component",
        "Cache-Control": "no-cache",
      },
    });
  } catch (err) {
    // Render error - don't crash the server
    const error = err instanceof Error ? err.message : String(err);
    const stack = err instanceof Error ? err.stack : undefined;
    console.error(\`[worker] Block "\${blockId}" render error:\`, err);
    return c.json({ error, stack }, 500);
  }
});

app.post("/blocks/:blockId{.+}/rsc", async (c) => {
  const blockId = c.req.param("blockId");

  // Dynamically load the block
  let Block: React.FC<any>;
  try {
    Block = await loadBlock(blockId);
  } catch (err) {
    // Import/load error - return the actual error
    const error = err instanceof Error ? err.message : String(err);
    const stack = err instanceof Error ? err.stack : undefined;
    console.error(\`[worker] Block "\${blockId}" load error:\`, err);
    return c.json({ error, stack }, 500);
  }

  const props = await c.req.json();

  // Set up request context for db access via AsyncLocalStorage
  const requestCtx = {
    db: c.get("db"),
    params: props,
    env: c.env,
  };

  try {
    // Wrap rendering with both contexts
    const rscContext = createRscRequestContext(c.req.raw);
    const stream = runWithContext(requestCtx, () =>
      runWithRequestInfo(rscContext, () =>
        renderToReadableStream(
          React.createElement(Block, props),
          createClientManifest()
        )
      )
    );

    return new Response(stream, {
      headers: {
        "Content-Type": "text/x-component",
        "Cache-Control": "no-cache",
      },
    });
  } catch (err) {
    // Render error - don't crash the server
    const error = err instanceof Error ? err.message : String(err);
    const stack = err instanceof Error ? err.stack : undefined;
    console.error(\`[worker] Block "\${blockId}" RSC render error:\`, err);
    return c.json({ error, stack }, 500);
  }
});

// === Workbook Routes ===
// Note: Postgres/DB routes are handled by runtime on RUNTIME_PORT

app.get("/workbook/manifest", async (c) => {
  const workbookDir = c.get("workbookDir");
  const workbookId = c.get("workbookId");
  const db = c.get("db");

  try {
    const manifest = await buildManifest(workbookDir, workbookId, db);
    return c.json(manifest);
  } catch (err) {
    return c.json({ error: String(err) }, 500);
  }
});

app.get("/workbook/pages/:pageId", async (c) => {
  const workbookDir = c.get("workbookDir");
  const pageId = c.req.param("pageId");

  try {
    const content = await getPageContent(workbookDir, pageId);
    return c.json({ success: true, pageId, content });
  } catch (err) {
    return c.json({ error: String(err) }, 404);
  }
});

app.put("/workbook/pages/:pageId", async (c) => {
  const workbookDir = c.get("workbookDir");
  const pageId = c.req.param("pageId");
  const { content } = await c.req.json<{ content: string }>();

  try {
    await savePageContent(workbookDir, pageId, content);
    return c.json({ success: true, pageId });
  } catch (err) {
    return c.json({ error: String(err) }, 500);
  }
});

app.post("/workbook/pages/create", async (c) => {
  const workbookDir = c.get("workbookDir");
  const { title } = await c.req.json<{ title?: string }>();

  try {
    const page = await createPage(workbookDir, title || "Untitled");
    return c.json({ success: true, page });
  } catch (err) {
    return c.json({ error: String(err) }, 500);
  }
});

// 404 fallback
app.all("*", (c) => c.notFound());

export default app;

// === Helpers ===

// tRPC client cache
let trpcClient: ReturnType<typeof createTRPCClient<any>> | null = null;
let trpcPort: number | null = null;

function getTRPC(runtimePort: number) {
  if (trpcClient && trpcPort === runtimePort) {
    return trpcClient;
  }
  trpcClient = createTRPCClient<any>({
    links: [
      httpBatchLink({
        url: \`http://localhost:\${runtimePort}/trpc\`,
      }),
    ],
  });
  trpcPort = runtimePort;
  return trpcClient;
}

// DB proxy that forwards queries to the runtime's PGlite instance via tRPC
function createDbProxy(runtimePort: number) {
  const trpc = getTRPC(runtimePort);

  // Tagged template literal for SQL queries
  const sql = async <T = Record<string, unknown>>(
    strings: TemplateStringsArray,
    ...values: unknown[]
  ): Promise<T[]> => {
    // Build parameterized query: "SELECT * FROM users WHERE id = $1"
    let queryText = strings[0];
    for (let i = 0; i < values.length; i++) {
      queryText += \`$\${i + 1}\` + strings[i + 1];
    }

    const result = await trpc.db.query.mutate({ query: queryText, params: values });
    return result.rows as T[];
  };

  return {
    sql,
    // pgtyped PreparedQuery support
    // PreparedQuery objects have a run(params, client) method that returns Promise<TResult[]>
    // We pass a fake client that routes queries through our tRPC proxy
    query: async <TParams, TResult>(
      preparedQuery: { run(params: TParams, client: unknown): Promise<TResult[]> },
      params: TParams
    ): Promise<TResult[]> => {
      // Create a fake pg client that routes queries through tRPC
      const fakeClient = {
        query: async (queryText: string, values?: unknown[]) => {
          const result = await trpc.db.query.mutate({ query: queryText, params: values });
          return { rows: result.rows };
        },
      };
      return preparedQuery.run(params, fakeClient);
    },
    tables: async () => {
      return await trpc.db.tables.query();
    },
  };
}

async function buildManifest(workbookDir: string, workbookId: string, db: any) {
  // Discover pages
  const pagesDir = join(workbookDir, "pages");
  let pages: any[] = [];
  try {
    const files = await readdir(pagesDir);
    for (const file of files) {
      if (file.endsWith(".md") || file.endsWith(".mdx")) {
        const content = await readFile(join(pagesDir, file), "utf-8");
        const title = extractTitle(content) || file.replace(/\\.(mdx?|md)$/, "");
        const id = file.replace(/\\.(mdx?|md)$/, "");
        pages.push({
          id,
          route: \`/\${id}\`,
          title,
          path: file,
        });
      }
    }
  } catch {
    // No pages directory
  }

  // Get blocks from known block IDs (populated at build time)
  const blocks = KNOWN_BLOCK_IDS.map(id => {
    // Extract filename for title (last part of path)
    const filename = id.includes("/") ? id.split("/").pop() : id;
    // Extract parent dir from path
    const parentDir = id.includes("/") ? id.substring(0, id.lastIndexOf("/")) : "";
    return {
      id,
      title: filename,
      path: id,
      parentDir,
    };
  });

  // Get tables from runtime via proxy
  let tables: string[] = [];
  try {
    const tablesResult = await db.tables();
    tables = tablesResult.map((r: any) => r.name || r.table_name);
  } catch {
    // DB not available yet (still booting)
  }

  // Read sources from hands.json
  const sources: any[] = [];
  try {
    const handsJson = await readFile(join(workbookDir, "hands.json"), "utf-8");
    const config = JSON.parse(handsJson);
    if (config.sources) {
      for (const [name, sc] of Object.entries(config.sources)) {
        sources.push({
          name,
          enabled: (sc as any).enabled !== false,
          schedule: (sc as any).schedule,
        });
      }
    }
  } catch {
    // No hands.json
  }

  const isEmpty = pages.length === 0 && blocks.length === 0 && sources.length === 0 && tables.length === 0;

  return {
    workbookId,
    workbookDir,
    pages,
    blocks,
    sources,
    tables,
    isEmpty,
  };
}

function extractTitle(content: string): string | null {
  // Try frontmatter
  const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);
  if (frontmatterMatch) {
    const titleMatch = frontmatterMatch[1].match(/title:\\s*["']?([^"'\\n]+)["']?/);
    if (titleMatch) return titleMatch[1];
  }
  // Try first heading
  const headingMatch = content.match(/^#\\s+(.+)$/m);
  if (headingMatch) return headingMatch[1];
  return null;
}

async function getPageContent(workbookDir: string, pageId: string): Promise<string> {
  const pagesDir = join(workbookDir, "pages");
  const mdxPath = join(pagesDir, \`\${pageId}.mdx\`);
  const mdPath = join(pagesDir, \`\${pageId}.md\`);

  try {
    return await readFile(mdxPath, "utf-8");
  } catch {
    return await readFile(mdPath, "utf-8");
  }
}

async function savePageContent(workbookDir: string, pageId: string, content: string): Promise<void> {
  const pagesDir = join(workbookDir, "pages");
  await mkdir(pagesDir, { recursive: true });

  const mdxPath = join(pagesDir, \`\${pageId}.mdx\`);
  await writeFile(mdxPath, content, "utf-8");
}

async function createPage(workbookDir: string, title: string) {
  const pagesDir = join(workbookDir, "pages");
  await mkdir(pagesDir, { recursive: true });

  const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "") || "untitled";
  let filename = \`\${slug}.mdx\`;
  let counter = 1;

  while (true) {
    try {
      await readFile(join(pagesDir, filename));
      filename = \`\${slug}-\${counter}.mdx\`;
      counter++;
    } catch {
      break;
    }
  }

  const content = \`---
title: "\${title}"
---

# \${title}

Start writing here...
\`;

  await writeFile(join(pagesDir, filename), content, "utf-8");

  return {
    id: filename.replace(/\\.mdx$/, ""),
    route: \`/\${filename.replace(/\\.mdx$/, "")}\`,
    title,
    path: filename,
  };
}
`;
}
