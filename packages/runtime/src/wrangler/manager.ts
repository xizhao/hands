/**
 * Wrangler dev server management using unstable_dev API
 *
 * Flow:
 * 1. Build: hands.json -> .hands/wrangler.toml + .hands/worker.ts
 * 2. Start: unstable_dev(.hands/worker.ts) with DATABASE_URL binding
 * 3. Watch: wrangler handles HMR for source file changes
 *
 * The generated worker.ts imports from ../src/, so wrangler watches
 * the actual source files through import resolution.
 */

import { unstable_dev, type Unstable_DevWorker } from "wrangler";
import { spawn } from "bun";
import { existsSync, readFileSync, writeFileSync } from "fs";
import { join, dirname } from "path";
import type { ServiceStatus, ServiceState, BuildError } from "../types";
import { build } from "../build";
// Note: wrangler.toml is now generated by the build system, no need to validate separately

interface WranglerManagerConfig {
  workbookDir: string;
  port: number;
  databaseUrl?: string;
}

// Find the monorepo root by looking for the root package.json with workspaces
function findMonorepoRoot(): string | null {
  // Start from runtime package and walk up
  let current = dirname(dirname(dirname(import.meta.dir)));

  for (let i = 0; i < 10; i++) {
    const pkgPath = join(current, "package.json");
    if (existsSync(pkgPath)) {
      try {
        const pkg = JSON.parse(readFileSync(pkgPath, "utf-8"));
        if (pkg.workspaces) {
          return current;
        }
      } catch {}
    }
    const parent = dirname(current);
    if (parent === current) break;
    current = parent;
  }
  return null;
}

/**
 * Check if a port is responding to HTTP requests
 */
async function checkPortReady(port: number, timeout = 2000): Promise<boolean> {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    const response = await fetch(`http://127.0.0.1:${port}/`, {
      method: "HEAD",
      signal: controller.signal,
    });
    clearTimeout(timeoutId);
    return response.ok || response.status < 500;
  } catch {
    return false;
  }
}

/**
 * Wait for port to become ready with polling
 */
async function waitForPort(port: number, maxWait = 30000): Promise<boolean> {
  const startTime = Date.now();
  while (Date.now() - startTime < maxWait) {
    if (await checkPortReady(port)) {
      return true;
    }
    await new Promise((resolve) => setTimeout(resolve, 500));
  }
  return false;
}

/**
 * Parse build/startup errors into structured format
 */
function parseError(error: unknown): BuildError[] {
  const errorStr = error instanceof Error ? error.message : String(error);
  const errors: BuildError[] = [];

  // Check for esbuild "Could not resolve" errors
  const resolveMatch = errorStr.match(/Could not resolve ["']([^"']+)["']/g);
  if (resolveMatch) {
    for (const match of resolveMatch) {
      const moduleMatch = match.match(/["']([^"']+)["']/);
      if (moduleMatch) {
        errors.push({
          type: "resolve",
          module: moduleMatch[1],
          message: `Could not resolve "${moduleMatch[1]}"`,
          suggestion: `Install the missing module or mark it as external`,
        });
      }
    }
  }

  // Check for syntax errors
  if (errorStr.includes("SyntaxError") || errorStr.includes("Parse error")) {
    const lineMatch = errorStr.match(/:(\d+):(\d+)/);
    errors.push({
      type: "syntax",
      line: lineMatch ? parseInt(lineMatch[1], 10) : undefined,
      column: lineMatch ? parseInt(lineMatch[2], 10) : undefined,
      message: errorStr.split("\n")[0],
    });
  }

  // Check for type errors
  if (errorStr.includes("TypeError") || errorStr.includes("type error")) {
    errors.push({
      type: "type",
      message: errorStr.split("\n")[0],
    });
  }

  // If no specific errors matched, add a generic one
  if (errors.length === 0) {
    errors.push({
      type: "other",
      message: errorStr.slice(0, 500), // Truncate long errors
    });
  }

  return errors;
}


export class WranglerManager {
  private config: WranglerManagerConfig;
  private worker: Unstable_DevWorker | null = null;
  private _state: ServiceState = "stopped";
  private _port: number;
  private _lastError?: string;
  private _startedAt?: number;
  private _restartCount = 0;
  private _buildErrors: BuildError[] = [];

  constructor(config: WranglerManagerConfig) {
    this.config = config;
    this._port = config.port;
  }

  get status(): ServiceStatus {
    return {
      state: this._state,
      up: this._state === "running",
      port: this._port,
      error: this._state === "failed" ? this._lastError : undefined,
      lastError: this._lastError,
      startedAt: this._startedAt,
      restartCount: this._restartCount,
      buildErrors: this._buildErrors.length > 0 ? this._buildErrors : undefined,
    };
  }

  get buildErrors(): BuildError[] {
    return this._buildErrors;
  }

  /**
   * Patch package.json to use file: reference for @hands/stdlib in dev mode
   */
  private patchPackageJson(): void {
    const monorepoRoot = findMonorepoRoot();
    if (!monorepoRoot) {
      console.log("Not in monorepo, skipping stdlib patch");
      return;
    }

    const stdlibPath = join(monorepoRoot, "packages", "stdlib");
    if (!existsSync(stdlibPath)) {
      console.log("stdlib not found at", stdlibPath);
      return;
    }

    const pkgPath = join(this.config.workbookDir, "package.json");
    if (!existsSync(pkgPath)) {
      return;
    }

    try {
      const pkg = JSON.parse(readFileSync(pkgPath, "utf-8"));
      if (pkg.dependencies?.["@hands/stdlib"]?.startsWith("workspace:")) {
        pkg.dependencies["@hands/stdlib"] = `file:${stdlibPath}`;
        writeFileSync(pkgPath, JSON.stringify(pkg, null, 2));
        console.log(`Patched @hands/stdlib -> file:${stdlibPath}`);
      }
    } catch (err) {
      console.log("Failed to patch package.json:", err);
    }
  }

  /**
   * Check if dependencies are installed
   */
  private async ensureDependencies(): Promise<void> {
    const nodeModules = join(this.config.workbookDir, "node_modules");

    if (existsSync(join(nodeModules, "hono"))) {
      // Already installed (check for a key dependency)
      return;
    }

    // Patch package.json for dev mode before install
    this.patchPackageJson();

    console.log("Installing workbook dependencies...");

    const proc = spawn(["bun", "install"], {
      cwd: this.config.workbookDir,
      stdout: "inherit",
      stderr: "inherit",
    });

    const exitCode = await proc.exited;
    if (exitCode !== 0) {
      throw new Error("Failed to install dependencies");
    }
  }

  /**
   * Run build from hands.json -> .hands/
   * Generates wrangler.toml and worker.ts entry point
   */
  private async runBuild(): Promise<{ outputDir: string; entryPoint: string }> {
    const handsJsonPath = join(this.config.workbookDir, "hands.json");

    if (!existsSync(handsJsonPath)) {
      throw new Error(
        `No hands.json found in ${this.config.workbookDir}. ` +
        `Create a hands.json to configure your workbook.`
      );
    }

    console.log("Building workbook from hands.json...");
    const result = await build(this.config.workbookDir, { dev: true });

    if (!result.success) {
      throw new Error(`Build failed: ${result.errors.join(", ")}`);
    }

    const entryPoint = join(result.outputDir, "worker.ts");
    if (!existsSync(entryPoint)) {
      throw new Error(`Build did not generate worker.ts entry point`);
    }

    console.log(`Build complete: ${result.files.join(", ")}`);
    return { outputDir: result.outputDir, entryPoint };
  }

  /**
   * Start the worker dev server
   */
  async start(): Promise<void> {
    if (this.worker && this._state === "running") {
      console.log("Worker already running");
      return;
    }

    this._state = "starting";
    this._buildErrors = [];

    try {
      // Ensure dependencies are installed
      await this.ensureDependencies();

      // Run build: hands.json -> .hands/wrangler.toml + .hands/worker.ts
      const { outputDir, entryPoint } = await this.runBuild();

      const wranglerConfig = join(outputDir, "wrangler.toml");
      console.log(`Starting worker from ${entryPoint} on port ${this._port}...`);

      // Start unstable_dev - don't await it directly since it can hang indefinitely
      // in non-interactive environments. Instead, start it and poll for readiness.
      let startupError: Error | null = null;
      const devPromise = unstable_dev(entryPoint, {
        port: this._port,
        local: true,
        config: wranglerConfig,
        // Suppress wrangler's own console output since we handle it
        logLevel: "warn",
        experimental: {
          disableExperimentalWarning: true,
        },
        // Pass DATABASE_URL as a binding - overrides what's in wrangler.toml
        vars: {
          DATABASE_URL: this.config.databaseUrl || "",
        },
      });

      // Capture any startup error
      devPromise
        .then((worker) => {
          this.worker = worker;
          // If we haven't already marked as running via polling, do it now
          if (this._state === "starting") {
            this._port = worker.port;
            this._state = "running";
            this._startedAt = Date.now();
            console.log(`Worker ready on port ${this._port}`);
          }
        })
        .catch((error) => {
          startupError = error;
          if (this._state === "starting") {
            this._state = "failed";
            this._lastError = error instanceof Error ? error.message : String(error);
            this._buildErrors = parseError(error);
            console.error("Worker failed to start:", this._lastError);
          }
        });

      // Poll for readiness - the worker usually starts before unstable_dev resolves
      console.log("Waiting for worker to become ready...");
      const ready = await waitForPort(this._port, 60000);

      // Check if there was a startup error
      if (startupError) {
        throw startupError;
      }

      if (ready) {
        // Worker is responding, mark as running even if unstable_dev hasn't resolved
        if (this._state === "starting") {
          this._state = "running";
          this._startedAt = Date.now();
          this._buildErrors = [];
          console.log(`Worker ready on port ${this._port}`);
        }
      } else {
        // Timeout waiting for worker
        throw new Error(`Worker did not become ready within 60 seconds on port ${this._port}`);
      }
    } catch (error) {
      this._state = "failed";
      this._lastError = error instanceof Error ? error.message : String(error);
      this._buildErrors = parseError(error);

      console.error("Worker failed to start:", this._lastError);
      throw error;
    }
  }

  /**
   * Stop the worker dev server
   */
  async stop(): Promise<void> {
    if (!this.worker) {
      this._state = "stopped";
      return;
    }

    console.log("Stopping worker...");

    try {
      await this.worker.stop();
    } catch (error) {
      console.error("Error stopping worker:", error);
    }

    this.worker = null;
    this._state = "stopped";
    console.log("Worker stopped");
  }

  /**
   * Restart the worker dev server
   */
  async restart(): Promise<void> {
    this._state = "restarting";
    this._restartCount++;
    await this.stop();
    await this.start();
  }

  /**
   * Switch to a different workbook
   */
  async switchWorkbook(newWorkbookDir: string): Promise<void> {
    console.log(`Switching worker to workbook: ${newWorkbookDir}`);
    await this.stop();
    this.config.workbookDir = newWorkbookDir;
    this._port = this.config.port; // Reset to original port
    this._restartCount = 0;
    this._buildErrors = [];
    await this.start();
  }

  /**
   * Make a request to the running worker
   * Note: Types are cast due to undici/Bun incompatibilities
   */
  async fetch(url: string, init?: Record<string, unknown>): Promise<Response> {
    if (!this.worker || this._state !== "running") {
      throw new Error("Worker is not running");
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (this.worker as any).fetch(url, init) as Response;
  }

  /**
   * Get the worker's address
   */
  get address(): string | undefined {
    return this.worker?.address;
  }
}
