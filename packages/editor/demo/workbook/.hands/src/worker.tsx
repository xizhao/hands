// Generated by hands RSC build system
// Regenerate with: hands build --rsc
// All-in-one worker with RSC blocks + API routes

import { Hono } from "hono";
import { cors } from "hono/cors";
import * as React from "react";
import { renderToReadableStream } from "react-server-dom-webpack/server.edge";
import { runWithRequestInfo } from "rwsdk/worker";
import { existsSync } from "node:fs";
import { readFile, writeFile, readdir, mkdir } from "node:fs/promises";
import { join } from "node:path";

// ============================================================================
// ARCHITECTURE NOTE: Why Static Block Imports?
// ============================================================================
//
// Blocks are statically imported (not dynamically) because of RSC/rwsdk constraints:
//
// 1. "use client" directives require Vite to process files at build/startup time
//    to populate the SSR bridge's module lookup table
//
// 2. Dynamic imports bypass Vite's transform pipeline, so client components
//    aren't registered and RSC rendering fails with "No module found" errors
//
// 3. The Vite worker subprocess is restarted when blocks are added/removed
//    (detected by the runtime's file watcher). This is fast (~1-2s) and only
//    happens on add/remove - edits to existing blocks use Vite's HMR.
//
// 4. This is the pragmatic solution that works with RSC's architecture rather
//    than fighting against it.
//
// ============================================================================

// Static block imports - Vite processes these at startup for RSC "use client" support
import Block0 from "../.././blocks/demo-chart.tsx";
import Block1 from "../.././blocks/demo-line-chart.tsx";
import Block2 from "../.././blocks/demo-metrics.tsx";
import Block3 from "../.././blocks/demo-table.tsx";

// Block registry populated from static imports
const BLOCKS: Record<string, React.FC<any>> = {
  "demo-chart": Block0,
  "demo-line-chart": Block1,
  "demo-metrics": Block2,
  "demo-table": Block3,
};

// ============================================================================
// Node ID Injection (inlined to avoid module resolution issues in Vite worker)
// ============================================================================

/**
 * Generate a stable node ID matching OXC parser format
 * Format: {tagname}_{path} where path is dot-separated indices
 */
function generateNodeId(tagName: string, path: number[]): string {
  const safeName = tagName.toLowerCase().replace(/[^a-z0-9]/g, "");
  const pathStr = path.join(".");
  return `${safeName}_${pathStr}`;
}

/**
 * Recursively traverse React elements and inject node IDs
 */
function NodeIdTraverser({
  element,
  path,
}: {
  element: React.ReactNode;
  path: number[];
}): React.ReactElement | null {
  if (element == null) return null;

  if (Array.isArray(element)) {
    return React.createElement(
      React.Fragment,
      null,
      element.map((child, idx) =>
        React.createElement(NodeIdTraverser, {
          key: idx,
          element: child,
          path: [...path.slice(0, -1), idx],
        })
      )
    );
  }

  if (typeof element === "string" || typeof element === "number" || typeof element === "boolean") {
    return React.createElement(React.Fragment, null, element);
  }

  if (React.isValidElement(element)) {
    const { type, props } = element;
    const children = (props as any).children;

    if (typeof type === "string") {
      const nodeId = generateNodeId(type, path);
      let childCounter = 0;
      const processedChildren = React.Children.map(children, (child) => {
        const childPath = [...path, childCounter++];
        return React.createElement(NodeIdTraverser, { element: child, path: childPath });
      });
      return React.cloneElement(element, { ...props, "data-node-id": nodeId } as any, processedChildren);
    }

    if (typeof type === "function") {
      let childCounter = 0;
      const processedChildren = React.Children.map(children, (child) => {
        const childPath = [...path, childCounter++];
        return React.createElement(NodeIdTraverser, { element: child, path: childPath });
      });
      return React.cloneElement(element, props, processedChildren);
    }

    let childCounter = 0;
    const processedChildren = React.Children.map(children, (child) => {
      const childPath = [...path, childCounter++];
      return React.createElement(NodeIdTraverser, { element: child, path: childPath });
    });
    return React.cloneElement(element, props, processedChildren);
  }

  return React.createElement(React.Fragment, null, element);
}

/**
 * HOC that wraps a Block component to inject node IDs
 */
function wrapWithNodeIdInjection<P extends Record<string, unknown>>(
  Block: React.ComponentType<P>,
  blockId: string
): React.ComponentType<P> {
  function WrappedBlock(props: P) {
    const element = React.createElement(Block, props);
    return React.createElement(NodeIdTraverser, { element, path: [0] });
  }
  WrappedBlock.displayName = `WithNodeIds(${(Block as any).displayName || (Block as any).name || blockId})`;
  return WrappedBlock;
}

// Client manifest for RSC serialization
// This Proxy handles "use client" component references without needing webpack infrastructure
const createClientManifest = () => new Proxy({}, {
  get(_, key) {
    return { id: key, name: key, chunks: [] };
  },
});

// Create RSC request context for "use client" serialization
// rwsdk transforms add scriptsToBeLoaded tracking to client modules
function createRscRequestContext(request: Request) {
  return {
    request,
    params: {},
    ctx: {},
    cf: {},
    response: {},
    rw: {
      scriptsToBeLoaded: new Set<string>(),
      entryScripts: new Set<string>(),
      inlineScripts: new Set<string>(),
      databases: new Map(),
      nonce: "",
      rscPayload: true,
      ssr: false,
    },
  };
}

// Types
type Bindings = {
  ENVIRONMENT: string;
  WORKBOOK_ID: string;
  WORKBOOK_DIR: string;
  RUNTIME_PORT: string;
};

type Variables = {
  db: ReturnType<typeof createDbProxy>;
  workbookDir: string;
  workbookId: string;
  runtimePort: number;
};

// Static block registry - see ARCHITECTURE NOTE above for why dynamic loading isn't used

// Create Hono app
const app = new Hono<{ Bindings: Bindings; Variables: Variables }>();

// === Middleware ===

// CORS
app.use("/*", cors());

// Request logging
app.use("/*", async (c, next) => {
  const start = Date.now();
  console.log(`[worker] → ${c.req.method} ${c.req.path}`);
  await next();
  const ms = Date.now() - start;
  console.log(`[worker] ← ${c.req.method} ${c.req.path} ${c.res.status} (${ms}ms)`);
});

// Initialize context
// Runtime port defaults to 55000 (PORTS.RUNTIME) for local dev
// In production, this would come from wrangler bindings
const DEFAULT_RUNTIME_PORT = 55000;

app.use("/*", async (c, next) => {
  const runtimePort = parseInt(c.env.RUNTIME_PORT, 10) || DEFAULT_RUNTIME_PORT;
  const db = createDbProxy(runtimePort);
  c.set("db", db);
  c.set("runtimePort", runtimePort);
  c.set("workbookDir", c.env.WORKBOOK_DIR || "/Users/kevin/hands-proto/packages/editor/demo/workbook");
  c.set("workbookId", c.env.WORKBOOK_ID || "editor-demo");
  await next();
});

// === Health/Status Routes ===

app.get("/health", (c) => {
  return c.json({
    status: "ok",
    name: "editor-demo",
    rsc: true,
    healthy: true,
  });
});

app.get("/status", (c) => {
  return c.json({
    workbookId: c.get("workbookId"),
    workbookDir: c.get("workbookDir"),
    rsc: true,
    runtimePort: c.get("runtimePort"),
  });
});

// === Block Routes (RSC) ===
// Editor-only routes for RSC block rendering
// Supports nested paths like /_editor/blocks/charts/bar-chart

app.get("/blocks", (c) => {
  return c.json({
    blocks: Object.keys(BLOCKS),
    format: "flight",
  });
});

// Use :blockId{.+} for multi-segment path matching (e.g., "charts/bar-chart")
app.get("/_editor/blocks/:blockId{.+}", async (c) => {
  const blockId = c.req.param("blockId");

  // ============================================================================
  // ARCHITECTURE NOTE: Why Static Imports Can't Be Dynamically Invalidated
  // ============================================================================
  //
  // We use static BLOCKS registry here (not dynamic imports) because:
  //
  // 1. Vite's SSR module runner doesn't support dynamic imports with variables
  //    (throws "cannot be analyzed" warnings and crashes with pre-bundle errors)
  //
  // 2. The static imports are processed once at Vite startup. File changes trigger
  //    Vite's HMR which updates the modules, but there's a race condition between
  //    file write and HMR propagation.
  //
  // 3. For now, the editor shows a loading state during mutations and refetches
  //    after the PUT succeeds. If the HMR hasn't propagated yet, users may need
  //    to wait or refresh. This is a known limitation.
  //
  // Future options to fix this properly:
  // - Use Vite's server.moduleGraph.invalidateModule() API
  // - Add a /invalidate endpoint that the runtime calls after file writes
  // - Switch to a non-RSC rendering path for editor preview
  //
  // ============================================================================

  const Block = BLOCKS[blockId];

  if (!Block) {
    return c.json({ error: `Block not found: ${blockId}` }, 404);
  }

  const url = new URL(c.req.url);
  const props = Object.fromEntries(url.searchParams);

  // Remove internal params from props passed to component
  delete props.edit;
  delete props._ts;

  const db = c.get("db");
  const ctx = {
    db,
    sql: db.sql,
    params: props,
    env: c.env,
  };

  try {
    // Wrap rendering with rwsdk request context for "use client" support
    const rscContext = createRscRequestContext(c.req.raw);
    const stream = runWithRequestInfo(rscContext, () =>
      renderToReadableStream(
        React.createElement(Block, { ...props, ctx }),
        createClientManifest()
      )
    );

    return new Response(stream, {
      headers: {
        "Content-Type": "text/x-component",
        "Cache-Control": "no-cache",
      },
    });
  } catch (err) {
    // Error boundary - don't crash the server
    const error = err instanceof Error ? err.message : String(err);
    const stack = err instanceof Error ? err.stack : undefined;
    console.error(`[worker] Block "${blockId}" render error:`, err);
    return c.json({ error, stack }, 500);
  }
});

app.post("/_editor/blocks/:blockId{.+}/rsc", async (c) => {
  const blockId = c.req.param("blockId");
  const Block = BLOCKS[blockId];

  if (!Block) {
    return c.json({ error: `Block not found: ${blockId}` }, 404);
  }

  const props = await c.req.json();
  const db = c.get("db");
  const ctx = {
    db,
    sql: db.sql,
    params: props,
    env: c.env,
  };

  try {
    // Wrap rendering with rwsdk request context for "use client" support
    const rscContext = createRscRequestContext(c.req.raw);
    const stream = runWithRequestInfo(rscContext, () =>
      renderToReadableStream(
        React.createElement(Block, { ...props, ctx }),
        createClientManifest()
      )
    );

    return new Response(stream, {
      headers: {
        "Content-Type": "text/x-component",
        "Cache-Control": "no-cache",
      },
    });
  } catch (err) {
    // Error boundary - don't crash the server
    const error = err instanceof Error ? err.message : String(err);
    const stack = err instanceof Error ? err.stack : undefined;
    console.error(`[worker] Block "${blockId}" RSC render error:`, err);
    return c.json({ error, stack }, 500);
  }
});

// === Workbook Routes ===
// Note: Postgres/DB routes are handled by runtime on RUNTIME_PORT

app.get("/workbook/manifest", async (c) => {
  const workbookDir = c.get("workbookDir");
  const workbookId = c.get("workbookId");
  const db = c.get("db");

  try {
    const manifest = await buildManifest(workbookDir, workbookId, db);
    return c.json(manifest);
  } catch (err) {
    return c.json({ error: String(err) }, 500);
  }
});

app.get("/workbook/pages/:pageId", async (c) => {
  const workbookDir = c.get("workbookDir");
  const pageId = c.req.param("pageId");

  try {
    const content = await getPageContent(workbookDir, pageId);
    return c.json({ success: true, pageId, content });
  } catch (err) {
    return c.json({ error: String(err) }, 404);
  }
});

app.put("/workbook/pages/:pageId", async (c) => {
  const workbookDir = c.get("workbookDir");
  const pageId = c.req.param("pageId");
  const { content } = await c.req.json<{ content: string }>();

  try {
    await savePageContent(workbookDir, pageId, content);
    return c.json({ success: true, pageId });
  } catch (err) {
    return c.json({ error: String(err) }, 500);
  }
});

app.post("/workbook/pages/create", async (c) => {
  const workbookDir = c.get("workbookDir");
  const { title } = await c.req.json<{ title?: string }>();

  try {
    const page = await createPage(workbookDir, title || "Untitled");
    return c.json({ success: true, page });
  } catch (err) {
    return c.json({ error: String(err) }, 500);
  }
});

// 404 fallback
app.all("*", (c) => c.notFound());

export default app;

// === Helpers ===

// DB proxy that forwards queries to the runtime's PGlite instance
function createDbProxy(runtimePort: number) {
  const baseUrl = `http://localhost:${runtimePort}`;

  const query = async (sql: string, params?: unknown[]) => {
    let response: Response;
    try {
      response = await fetch(`${baseUrl}/db/query`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query: sql, params }),
      });
    } catch (fetchError) {
      // Network error - runtime not reachable
      const err = new Error(`Database connection failed: ${fetchError instanceof Error ? fetchError.message : String(fetchError)}`);
      (err as any).cause = fetchError;
      throw err;
    }

    if (!response.ok) {
      let errorMessage = "Database query failed";
      try {
        const errorBody = await response.json();
        errorMessage = errorBody.error || errorBody.message || errorMessage;
      } catch {
        // Response wasn't JSON, try text
        try {
          errorMessage = await response.text() || errorMessage;
        } catch {
          // Ignore
        }
      }
      throw new Error(errorMessage);
    }

    const result = await response.json();
    return result.rows;
  };

  // Tagged template literal for SQL queries
  const sql = async <T = Record<string, unknown>>(
    strings: TemplateStringsArray,
    ...values: unknown[]
  ): Promise<T[]> => {
    // Build parameterized query: "SELECT * FROM users WHERE id = $1"
    let queryText = strings[0];
    const params: unknown[] = [];

    for (let i = 0; i < values.length; i++) {
      params.push(values[i]);
      queryText += `$${i + 1}` + strings[i + 1];
    }

    return query(queryText, params) as Promise<T[]>;
  };

  return {
    query,
    sql,
    tables: async () => {
      let response: Response;
      try {
        response = await fetch(`${baseUrl}/db/tables`);
      } catch (fetchError) {
        const err = new Error(`Failed to fetch tables: ${fetchError instanceof Error ? fetchError.message : String(fetchError)}`);
        (err as any).cause = fetchError;
        throw err;
      }
      if (!response.ok) {
        let errorMessage = "Failed to fetch tables";
        try {
          const errorBody = await response.json();
          errorMessage = errorBody.error || errorBody.message || errorMessage;
        } catch {
          try {
            errorMessage = await response.text() || errorMessage;
          } catch {
            // Ignore
          }
        }
        throw new Error(errorMessage);
      }
      return response.json();
    },
  };
}

async function buildManifest(workbookDir: string, workbookId: string, db: any) {
  // Discover pages
  const pagesDir = join(workbookDir, "pages");
  let pages: any[] = [];
  try {
    const files = await readdir(pagesDir);
    for (const file of files) {
      if (file.endsWith(".md") || file.endsWith(".mdx")) {
        const content = await readFile(join(pagesDir, file), "utf-8");
        const title = extractTitle(content) || file.replace(/\.(mdx?|md)$/, "");
        const id = file.replace(/\.(mdx?|md)$/, "");
        pages.push({
          id,
          route: `/${id}`,
          title,
          path: file,
        });
      }
    }
  } catch {
    // No pages directory
  }

  // Get blocks from static registry (populated at build time)
  const blocks = Object.keys(BLOCKS).map(id => {
    // Extract filename for title (last part of path)
    const filename = id.includes("/") ? id.split("/").pop() : id;
    // Extract parent dir from path
    const parentDir = id.includes("/") ? id.substring(0, id.lastIndexOf("/")) : "";
    return {
      id,
      title: filename,
      path: id,
      parentDir,
    };
  });

  // Get tables from runtime via proxy
  let tables: string[] = [];
  try {
    const tablesResult = await db.tables();
    tables = tablesResult.map((r: any) => r.name || r.table_name);
  } catch {
    // DB not available yet (still booting)
  }

  // Read sources from hands.json
  const sources: any[] = [];
  try {
    const handsJson = await readFile(join(workbookDir, "hands.json"), "utf-8");
    const config = JSON.parse(handsJson);
    if (config.sources) {
      for (const [name, sc] of Object.entries(config.sources)) {
        sources.push({
          name,
          enabled: (sc as any).enabled !== false,
          schedule: (sc as any).schedule,
        });
      }
    }
  } catch {
    // No hands.json
  }

  const isEmpty = pages.length === 0 && blocks.length === 0 && sources.length === 0 && tables.length === 0;

  return {
    workbookId,
    workbookDir,
    pages,
    blocks,
    sources,
    tables,
    isEmpty,
  };
}

function extractTitle(content: string): string | null {
  // Try frontmatter
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (frontmatterMatch) {
    const titleMatch = frontmatterMatch[1].match(/title:\s*["']?([^"'\n]+)["']?/);
    if (titleMatch) return titleMatch[1];
  }
  // Try first heading
  const headingMatch = content.match(/^#\s+(.+)$/m);
  if (headingMatch) return headingMatch[1];
  return null;
}

async function getPageContent(workbookDir: string, pageId: string): Promise<string> {
  const pagesDir = join(workbookDir, "pages");
  const mdxPath = join(pagesDir, `${pageId}.mdx`);
  const mdPath = join(pagesDir, `${pageId}.md`);

  try {
    return await readFile(mdxPath, "utf-8");
  } catch {
    return await readFile(mdPath, "utf-8");
  }
}

async function savePageContent(workbookDir: string, pageId: string, content: string): Promise<void> {
  const pagesDir = join(workbookDir, "pages");
  await mkdir(pagesDir, { recursive: true });

  const mdxPath = join(pagesDir, `${pageId}.mdx`);
  await writeFile(mdxPath, content, "utf-8");
}

async function createPage(workbookDir: string, title: string) {
  const pagesDir = join(workbookDir, "pages");
  await mkdir(pagesDir, { recursive: true });

  const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "") || "untitled";
  let filename = `${slug}.mdx`;
  let counter = 1;

  while (true) {
    try {
      await readFile(join(pagesDir, filename));
      filename = `${slug}-${counter}.mdx`;
      counter++;
    } catch {
      break;
    }
  }

  const content = `---
title: "${title}"
---

# ${title}

Start writing here...
`;

  await writeFile(join(pagesDir, filename), content, "utf-8");

  return {
    id: filename.replace(/\.mdx$/, ""),
    route: `/${filename.replace(/\.mdx$/, "")}`,
    title,
    path: filename,
  };
}
