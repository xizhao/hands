/**
 * Workbook Manifest Generation
 *
 * Generates manifest files for runtime consumption.
 */

import { existsSync, mkdirSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import type { ResolvedWorkbookConfig, WorkbookManifest } from "./types.js";
import { discoverWorkbook, resolveConfig, type WorkbookConfig } from "./discovery.js";

/**
 * Generate all manifest files for a workbook
 */
export async function generateManifests(config: WorkbookConfig): Promise<WorkbookManifest> {
  const resolved = resolveConfig(config);
  const manifest = await discoverWorkbook(config);

  // Ensure output directory exists
  if (!existsSync(resolved.outDir)) {
    mkdirSync(resolved.outDir, { recursive: true });
  }

  // Generate pages manifest (TypeScript module for runtime)
  generatePagesManifest(resolved, manifest);

  // Generate blocks manifest (JSON for tooling)
  generateBlocksManifest(resolved, manifest);

  // Generate full manifest (JSON for debugging)
  writeFileSync(
    join(resolved.outDir, "manifest.json"),
    JSON.stringify(manifest, null, 2),
    "utf-8"
  );

  return manifest;
}

/**
 * Generate pages/index.tsx for runtime route registration
 */
function generatePagesManifest(config: ResolvedWorkbookConfig, manifest: WorkbookManifest): void {
  const pagesDir = join(config.outDir, "pages");
  if (!existsSync(pagesDir)) {
    mkdirSync(pagesDir, { recursive: true });
  }

  const imports: string[] = [];
  const routes: string[] = [];

  for (const page of manifest.pages) {
    const varName = pageRouteToVarName(page.route);
    const importPath = `../../pages/${page.path}`;

    if (page.ext === ".mdx") {
      imports.push(`import ${varName}Content from "${importPath}";`);
      routes.push(`  route("${page.route}", () => <${varName}Content />),`);
    } else if (page.ext === ".md") {
      // Plain markdown needs a wrapper
      imports.push(`import ${varName}Content from "${importPath}?raw";`);
      routes.push(`  route("${page.route}", () => <MarkdownPage content={${varName}Content} />),`);
    }
    // .plate.json would need special handling
  }

  const code = `// Auto-generated by workbook discovery
// Do not edit manually
import { route } from "rwsdk/router";

${imports.join("\n")}

export const pageRoutes = [
${routes.join("\n")}
];
`;

  writeFileSync(join(pagesDir, "index.tsx"), code, "utf-8");
}

/**
 * Generate blocks.json for editor/tooling
 */
function generateBlocksManifest(config: ResolvedWorkbookConfig, manifest: WorkbookManifest): void {
  const blocksData = manifest.blocks.map((block) => ({
    id: block.id,
    path: block.path,
    parentDir: block.parentDir,
    title: block.meta.title || block.id,
    description: block.meta.description,
    refreshable: block.meta.refreshable,
    uninitialized: block.uninitialized,
  }));

  writeFileSync(
    join(config.outDir, "blocks.json"),
    JSON.stringify(blocksData, null, 2),
    "utf-8"
  );
}

/**
 * Convert route path to valid variable name
 */
function pageRouteToVarName(route: string): string {
  if (route === "/") return "Index";

  return route
    .split("/")
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("")
    .replace(/[^a-zA-Z0-9]/g, "_");
}

/**
 * Watch workbook for changes and regenerate manifests
 * Note: Requires chokidar to be installed
 */
export async function watchWorkbook(
  config: WorkbookConfig,
  onChange: (manifest: WorkbookManifest) => void
): Promise<() => void> {
  const resolved = resolveConfig(config);

  // Dynamic import chokidar - caller must ensure it's installed
  let chokidar: any;
  try {
    // @ts-expect-error - chokidar is an optional peer dependency
    chokidar = await import("chokidar");
  } catch {
    throw new Error("chokidar is required for watchWorkbook. Install with: bun add chokidar");
  }

  const watcher = chokidar.watch(
    [resolved.blocksDir, resolved.pagesDir, resolved.uiDir].filter(existsSync),
    {
      ignoreInitial: true,
      ignored: /(^|[\/\\])\../, // ignore dotfiles
    }
  );

  let debounceTimer: NodeJS.Timeout | null = null;

  const regenerate = async () => {
    try {
      const manifest = await generateManifests(config);
      onChange(manifest);
    } catch (err) {
      console.error("Failed to regenerate manifests:", err);
    }
  };

  watcher.on("all", () => {
    if (debounceTimer) clearTimeout(debounceTimer);
    debounceTimer = setTimeout(regenerate, 100);
  });

  // Initial generation
  regenerate();

  return () => {
    watcher.close();
    if (debounceTimer) clearTimeout(debounceTimer);
  };
}
