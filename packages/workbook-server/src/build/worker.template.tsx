// Generated by hands RSC build system
// Regenerate with: hands build --rsc
// All-in-one worker with RSC blocks + API routes

import { defineApp, runWithRequestInfo } from "rwsdk/worker";
import { route } from "rwsdk/router";
import * as React from "react";
// @ts-expect-error - no types for react-server-dom-webpack
import { renderToReadableStream } from "react-server-dom-webpack/server.edge";
import { readFile, writeFile, readdir, mkdir } from "node:fs/promises";
import { join } from "node:path";
import { createTRPCClient, httpBatchLink } from "@trpc/client";
import { AsyncLocalStorage } from "node:async_hooks";

// ============================================================================
// INJECTED CONFIG - replaced at build time
// ============================================================================
const __HANDS_CONFIG__ = {
  workbookName: "__WORKBOOK_NAME__",
  workbookDir: "__WORKBOOK_DIR__",
  blocksDir: "__BLOCKS_DIR__",
  blockIds: "__BLOCK_IDS__" as unknown as string[],
};

// ============================================================================
// @hands/db - Database access for server components
// ============================================================================
// Blocks import { sql } from '@hands/db' to query the database.
// The worker sets up request context before rendering via AsyncLocalStorage.
// ============================================================================

interface DbContext {
  sql<T>(strings: TemplateStringsArray, ...values: unknown[]): Promise<T[]>;
  query<TParams, TResult>(
    preparedQuery: { run(params: TParams, client: unknown): Promise<TResult[]> },
    params: TParams
  ): Promise<TResult[]>;
}

interface RequestContext {
  db: DbContext;
  params: Record<string, unknown>;
  env: Record<string, unknown>;
}

const requestContext = new AsyncLocalStorage<RequestContext>();

function runWithContext<T>(ctx: RequestContext, fn: () => T): T {
  return requestContext.run(ctx, fn);
}

function getContext(): RequestContext {
  const ctx = requestContext.getStore();
  if (!ctx) {
    throw new Error(
      "[hands] Database can only be accessed during request handling, not at module load time."
    );
  }
  return ctx;
}

/**
 * Tagged template for SQL queries
 * @example
 * import { sql } from '@hands/db'
 * const users = await sql<User>`SELECT * FROM users WHERE active = ${true}`
 */
export function sql<T = Record<string, unknown>>(
  strings: TemplateStringsArray,
  ...values: unknown[]
): Promise<T[]> {
  return getContext().db.sql<T>(strings, ...values);
}

/**
 * Execute a pgtyped prepared query
 * @example
 * import { query } from '@hands/db'
 * import { getUsers } from './queries.types'
 * const users = await query(getUsers, { active: true })
 */
export function query<TParams, TResult>(
  preparedQuery: { run(params: TParams, client: unknown): Promise<TResult[]> },
  params: TParams
): Promise<TResult[]> {
  return getContext().db.query(preparedQuery, params);
}

/**
 * Get URL/form params from the current request
 * @example
 * import { params } from '@hands/db'
 * const { limit = 10 } = params<{ limit?: number }>()
 */
export function params<T = Record<string, unknown>>(): T {
  return getContext().params as T;
}

/**
 * Get environment bindings
 * @example
 * import { env } from '@hands/db'
 * const { API_KEY } = env<{ API_KEY: string }>()
 */
export function env<T = Record<string, unknown>>(): T {
  return getContext().env as T;
}

// ============================================================================
// ARCHITECTURE: Dynamic Block Imports
// ============================================================================
//
// Blocks are loaded dynamically via import() because:
//
// 1. rwsdk/Vite watches block files and recompiles "use client" bundles on change
// 2. Dynamic imports get the updated module from Vite's module graph
// 3. No server restart needed when blocks are added/removed/edited
// 4. Vite's HMR handles cache invalidation automatically
//
// ============================================================================

// Known block IDs at build time (for manifest)
const KNOWN_BLOCK_IDS: string[] = __HANDS_CONFIG__.blockIds;

// Module cache for loaded blocks
const blockCache = new Map<string, React.FC<any>>();

// Error cache for blocks that failed to load (cleared on HMR)
const blockErrorCache = new Map<string, Error>();

/**
 * Dynamically load a block by ID
 * Uses Vite's module resolution which handles "use client" transforms
 * Throws on error so callers can return proper error responses
 */
async function loadBlock(blockId: string): Promise<React.FC<any>> {
  // Check error cache first (avoid repeated failed imports)
  if (blockErrorCache.has(blockId)) {
    throw blockErrorCache.get(blockId)!;
  }

  // Check success cache
  if (blockCache.has(blockId)) {
    return blockCache.get(blockId)!;
  }

  try {
    // Dynamic import - Vite resolves this and applies RSC transforms
    // Path is relative to .hands/src/worker.tsx
    const mod = await import(`../../${__HANDS_CONFIG__.blocksDir}/${blockId}.tsx`);
    const Block = mod.default;
    if (!Block) {
      throw new Error(`Block "${blockId}" has no default export`);
    }
    blockCache.set(blockId, Block);
    return Block;
  } catch (err) {
    const error = err instanceof Error ? err : new Error(String(err));
    console.error(`[worker] Failed to load block "${blockId}":`, error);
    blockErrorCache.set(blockId, error);
    throw error;
  }
}

/**
 * Clear the block cache (called on HMR updates)
 */
function clearBlockCache(blockId?: string) {
  if (blockId) {
    blockCache.delete(blockId);
    blockErrorCache.delete(blockId);
  } else {
    blockCache.clear();
    blockErrorCache.clear();
  }
}

// Client manifest for RSC serialization
// This Proxy handles "use client" component references without needing webpack infrastructure
const createClientManifest = () =>
  new Proxy(
    {},
    {
      get(_, key) {
        return { id: key, name: key, chunks: [] };
      },
    }
  );

// Create RSC request context for "use client" serialization
// rwsdk transforms add scriptsToBeLoaded tracking to client modules
function createRscRequestContext(request: Request): any {
  return {
    request,
    params: {},
    ctx: {},
    cf: {},
    response: {},
    isAction: false,
    rw: {
      scriptsToBeLoaded: new Set<string>(),
      entryScripts: new Set<string>(),
      inlineScripts: new Set<string>(),
      databases: new Map(),
      nonce: "",
      rscPayload: true,
      ssr: false,
    },
  };
}

// Runtime port - injected at build time via vite define config
const DEFAULT_RUNTIME_PORT = 55000;

// === Route Handlers ===
// Using 'any' for handler params to avoid complex rwsdk type gymnastics

async function handleHealth({ ctx }: any) {
  return Response.json({
    status: "ok",
    name: __HANDS_CONFIG__.workbookName,
    rsc: true,
    healthy: true,
  });
}

async function handleStatus({ ctx }: any) {
  return Response.json({
    workbookId: ctx.workbookId,
    workbookDir: ctx.workbookDir,
    rsc: true,
    runtimePort: ctx.runtimePort,
  });
}

async function handleBlocksList() {
  return Response.json({
    blocks: KNOWN_BLOCK_IDS,
    format: "flight",
  });
}

async function handleBlockInvalidate({ request }: any) {
  const { blockId } = (await request.json()) as { blockId?: string };
  clearBlockCache(blockId);
  return Response.json({ success: true, cleared: blockId || "all" });
}

async function handleBlockGet({ request, ctx, params }: any) {
  // params.$0 contains the wildcard match for /blocks/*
  const blockId = params.$0;

  // Dynamically load the block - Vite handles "use client" transforms
  let Block: React.FC<any>;
  try {
    Block = await loadBlock(blockId);
  } catch (err) {
    const error = err instanceof Error ? err.message : String(err);
    const stack = err instanceof Error ? err.stack : undefined;
    console.error(`[worker] Block "${blockId}" load error:`, err);
    return Response.json({ error, stack }, { status: 500 });
  }

  const url = new URL(request.url);
  const props = Object.fromEntries(url.searchParams);

  // Remove internal params from props passed to component
  delete props.edit;
  delete props._ts;

  // Set up request context for db access via AsyncLocalStorage
  const requestCtx = {
    db: ctx.db,
    params: props,
    env: {},
  };

  try {
    const rscContext = createRscRequestContext(request);
    const stream = runWithContext(requestCtx, () =>
      runWithRequestInfo(rscContext, () =>
        renderToReadableStream(React.createElement(Block, props), createClientManifest())
      )
    );

    return new Response(stream, {
      headers: {
        "Content-Type": "text/x-component",
        "Cache-Control": "no-cache",
      },
    });
  } catch (err) {
    const error = err instanceof Error ? err.message : String(err);
    const stack = err instanceof Error ? err.stack : undefined;
    console.error(`[worker] Block "${blockId}" render error:`, err);
    return Response.json({ error, stack }, { status: 500 });
  }
}

async function handleBlockRscPost({ request, ctx, params }: any) {
  // Extract blockId from path - params.$0 contains everything after /blocks/
  const fullPath = params.$0 || "";
  // Remove /rsc suffix to get the blockId
  const blockId = fullPath.replace(/\/rsc$/, "");

  let Block: React.FC<any>;
  try {
    Block = await loadBlock(blockId);
  } catch (err) {
    const error = err instanceof Error ? err.message : String(err);
    const stack = err instanceof Error ? err.stack : undefined;
    console.error(`[worker] Block "${blockId}" load error:`, err);
    return Response.json({ error, stack }, { status: 500 });
  }

  const props = await request.json();

  const requestCtx = {
    db: ctx.db,
    params: props as Record<string, unknown>,
    env: {},
  };

  try {
    const rscContext = createRscRequestContext(request);
    const stream = runWithContext(requestCtx, () =>
      runWithRequestInfo(rscContext, () =>
        renderToReadableStream(React.createElement(Block, props), createClientManifest())
      )
    );

    return new Response(stream, {
      headers: {
        "Content-Type": "text/x-component",
        "Cache-Control": "no-cache",
      },
    });
  } catch (err) {
    const error = err instanceof Error ? err.message : String(err);
    const stack = err instanceof Error ? err.stack : undefined;
    console.error(`[worker] Block "${blockId}" RSC render error:`, err);
    return Response.json({ error, stack }, { status: 500 });
  }
}

async function handleManifest({ ctx }: any) {
  try {
    const manifest = await buildManifest(ctx.workbookDir, ctx.workbookId, ctx.db);
    return Response.json(manifest);
  } catch (err) {
    return Response.json({ error: String(err) }, { status: 500 });
  }
}

async function handlePageGet({ ctx, params }: any) {
  try {
    const content = await getPageContent(ctx.workbookDir, params.pageId);
    return Response.json({ success: true, pageId: params.pageId, content });
  } catch (err) {
    return Response.json({ error: String(err) }, { status: 404 });
  }
}

async function handlePagePut({ request, ctx, params }: any) {
  const { content } = (await request.json()) as { content: string };

  try {
    await savePageContent(ctx.workbookDir, params.pageId, content);
    return Response.json({ success: true, pageId: params.pageId });
  } catch (err) {
    return Response.json({ error: String(err) }, { status: 500 });
  }
}

async function handlePageCreate({ request, ctx }: any) {
  const { title } = (await request.json()) as { title?: string };

  try {
    const page = await createPage(ctx.workbookDir, title || "Untitled");
    return Response.json({ success: true, page });
  } catch (err) {
    return Response.json({ error: String(err) }, { status: 500 });
  }
}

// === App Definition ===
// Note: Using 'any' for defineApp type param because rwsdk's RequestInfo type is complex
// and our middleware extends ctx with custom properties. Runtime behavior is correct.

export default defineApp([
  // Middleware: CORS headers
  ({ request, ctx }: any) => {
    // Add CORS headers to all responses via response interceptor
    ctx._corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type",
    };

    // Handle preflight
    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: ctx._corsHeaders as HeadersInit });
    }
  },

  // Middleware: Request logging
  ({ request, ctx }: any) => {
    const url = new URL(request.url);
    ctx._requestStart = Date.now();
    console.log(`[worker] â†’ ${request.method} ${url.pathname}`);
  },

  // Middleware: Initialize context
  ({ ctx }: any) => {
    const runtimePort = parseInt(process.env.RUNTIME_PORT || "", 10) || DEFAULT_RUNTIME_PORT;
    ctx.db = createDbProxy(runtimePort);
    ctx.runtimePort = runtimePort;
    ctx.workbookDir = __HANDS_CONFIG__.workbookDir;
    ctx.workbookId = __HANDS_CONFIG__.workbookName;
  },

  // Routes
  route("/health", handleHealth),
  route("/status", handleStatus),
  route("/blocks", handleBlocksList),
  route("/blocks/invalidate", { post: handleBlockInvalidate }),
  // Wildcard routes for blocks - rwsdk uses * for wildcards
  route("/blocks/*", {
    get: handleBlockGet,
    post: handleBlockRscPost,
  }),

  // Workbook routes
  route("/workbook/manifest", handleManifest),
  route("/workbook/pages/create", { post: handlePageCreate }),
  route("/workbook/pages/:pageId", {
    get: handlePageGet,
    put: handlePagePut,
  }),
]);

// === Helpers ===

// tRPC client cache - typed as 'any' since we don't have the router type here
let trpcClient: any = null;
let trpcPort: number | null = null;

function getTRPC(runtimePort: number): any {
  if (trpcClient && trpcPort === runtimePort) {
    return trpcClient;
  }
  trpcClient = createTRPCClient({
    links: [
      httpBatchLink({
        url: `http://localhost:${runtimePort}/trpc`,
      }),
    ],
  });
  trpcPort = runtimePort;
  return trpcClient;
}

// DB proxy that forwards queries to the runtime's PGlite instance via tRPC
function createDbProxy(runtimePort: number) {
  const trpc = getTRPC(runtimePort);

  // Tagged template literal for SQL queries
  const sql = async <T = Record<string, unknown>>(
    strings: TemplateStringsArray,
    ...values: unknown[]
  ): Promise<T[]> => {
    // Build parameterized query: "SELECT * FROM users WHERE id = $1"
    let queryText = strings[0];
    for (let i = 0; i < values.length; i++) {
      queryText += `$${i + 1}` + strings[i + 1];
    }

    const result = await trpc.db.query.mutate({ query: queryText, params: values });
    return result.rows as T[];
  };

  return {
    sql,
    // pgtyped PreparedQuery support
    // PreparedQuery objects have a run(params, client) method that returns Promise<TResult[]>
    // We pass a fake client that routes queries through our tRPC proxy
    query: async <TParams, TResult>(
      preparedQuery: { run(params: TParams, client: unknown): Promise<TResult[]> },
      params: TParams
    ): Promise<TResult[]> => {
      // Create a fake pg client that routes queries through tRPC
      const fakeClient = {
        query: async (queryText: string, values?: unknown[]) => {
          const result = await trpc.db.query.mutate({ query: queryText, params: values });
          return { rows: result.rows };
        },
      };
      return preparedQuery.run(params, fakeClient);
    },
    tables: async () => {
      return await trpc.db.tables.query();
    },
  };
}

async function buildManifest(workbookDir: string, workbookId: string, db: any) {
  // Discover pages
  const pagesDir = join(workbookDir, "pages");
  let pages: any[] = [];
  try {
    const files = await readdir(pagesDir);
    for (const file of files) {
      if (file.endsWith(".md") || file.endsWith(".mdx")) {
        const content = await readFile(join(pagesDir, file), "utf-8");
        const title = extractTitle(content) || file.replace(/\.(mdx?|md)$/, "");
        const id = file.replace(/\.(mdx?|md)$/, "");
        pages.push({
          id,
          route: `/${id}`,
          title,
          path: file,
        });
      }
    }
  } catch {
    // No pages directory
  }

  // Get blocks from known block IDs (populated at build time)
  const blocks = KNOWN_BLOCK_IDS.map((id) => {
    // Extract filename for title (last part of path)
    const filename = id.includes("/") ? id.split("/").pop() : id;
    // Extract parent dir from path
    const parentDir = id.includes("/") ? id.substring(0, id.lastIndexOf("/")) : "";
    return {
      id,
      title: filename,
      path: id,
      parentDir,
    };
  });

  // Get tables from runtime via proxy
  let tables: string[] = [];
  try {
    const tablesResult = await db.tables();
    tables = tablesResult.map((r: any) => r.name || r.table_name);
  } catch {
    // DB not available yet (still booting)
  }

  // Read sources from package.json hands config
  const sources: any[] = [];
  try {
    const pkgJson = await readFile(join(workbookDir, "package.json"), "utf-8");
    const pkg = JSON.parse(pkgJson);
    const config = pkg.hands || {};
    if (config.sources) {
      for (const [name, sc] of Object.entries(config.sources)) {
        sources.push({
          name,
          enabled: (sc as any).enabled !== false,
          schedule: (sc as any).schedule,
        });
      }
    }
  } catch {
    // No package.json or no hands config
  }

  const isEmpty =
    pages.length === 0 && blocks.length === 0 && sources.length === 0 && tables.length === 0;

  return {
    workbookId,
    workbookDir,
    pages,
    blocks,
    sources,
    tables,
    isEmpty,
  };
}

function extractTitle(content: string): string | null {
  // Try frontmatter
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (frontmatterMatch) {
    const titleMatch = frontmatterMatch[1].match(/title:\s*["']?([^"'\n]+)["']?/);
    if (titleMatch) return titleMatch[1];
  }
  // Try first heading
  const headingMatch = content.match(/^#\s+(.+)$/m);
  if (headingMatch) return headingMatch[1];
  return null;
}

async function getPageContent(workbookDir: string, pageId: string): Promise<string> {
  const pagesDir = join(workbookDir, "pages");
  const mdxPath = join(pagesDir, `${pageId}.mdx`);
  const mdPath = join(pagesDir, `${pageId}.md`);

  try {
    return await readFile(mdxPath, "utf-8");
  } catch {
    return await readFile(mdPath, "utf-8");
  }
}

async function savePageContent(
  workbookDir: string,
  pageId: string,
  content: string
): Promise<void> {
  const pagesDir = join(workbookDir, "pages");
  await mkdir(pagesDir, { recursive: true });

  const mdxPath = join(pagesDir, `${pageId}.mdx`);
  await writeFile(mdxPath, content, "utf-8");
}

async function createPage(workbookDir: string, title: string) {
  const pagesDir = join(workbookDir, "pages");
  await mkdir(pagesDir, { recursive: true });

  const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "") || "untitled";
  let filename = `${slug}.mdx`;
  let counter = 1;

  while (true) {
    try {
      await readFile(join(pagesDir, filename));
      filename = `${slug}-${counter}.mdx`;
      counter++;
    } catch {
      break;
    }
  }

  const content = `---
title: "${title}"
---

# ${title}

Start writing here...
`;

  await writeFile(join(pagesDir, filename), content, "utf-8");

  return {
    id: filename.replace(/\.mdx$/, ""),
    route: `/${filename.replace(/\.mdx$/, "")}`,
    title,
    path: filename,
  };
}
