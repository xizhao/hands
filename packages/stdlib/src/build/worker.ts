import type { HandsJson } from "./schema.js"
import { registry } from "../sources/index.js"

/**
 * Generate worker.ts entry point from hands.json
 */
export function generateWorkerEntry(config: HandsJson): string {
  const enabledSources = Object.entries(config.sources)
    .filter(([_, cfg]) => cfg.enabled)
    .map(([name]) => name)

  // Build imports
  const imports: string[] = [
    "// Auto-generated by `hands build` - do not edit",
    "",
    'import type { SourceContext, SqlClient } from "@hands/stdlib"',
    "",
    "// User's main app",
    'import app from "../src/index"',
    "",
  ]

  // Import each enabled source
  if (enabledSources.length > 0) {
    imports.push("// Sources")
    for (const name of enabledSources) {
      imports.push(`import * as ${sanitizeName(name)} from "../sources/${name}"`)
    }
    imports.push("")
  }

  // Build cron-to-source mapping
  const cronMap = new Map<string, string[]>()
  for (const [sourceName, sourceConfig] of Object.entries(config.sources)) {
    if (!sourceConfig.enabled) continue

    let schedule = sourceConfig.schedule
    if (!schedule) {
      const registryItem = registry.items.find((i) => i.name === sourceName)
      schedule = registryItem?.schedule ?? "0 * * * *"
    }

    if (!cronMap.has(schedule)) {
      cronMap.set(schedule, [])
    }
    cronMap.get(schedule)!.push(sourceName)
  }

  // Get table names for each source from registry
  const sourceToTable = new Map<string, string>()
  for (const name of enabledSources) {
    const registryItem = registry.items.find((i) => i.name === name)
    // Use first table as primary, or fall back to source name
    const table = registryItem?.tables?.[0] ?? `${name}_data`
    sourceToTable.set(name, table)
  }

  // Build the worker code
  const code: string[] = [
    ...imports,
    "// Types",
    "interface Env {",
    "  DATABASE_URL: string",
    "  KV?: KVNamespace",
    "  [key: string]: unknown",
    "}",
    "",
    "interface KVNamespace {",
    "  get(key: string): Promise<string | null>",
    "  put(key: string, value: string): Promise<void>",
    "}",
    "",
    "// SQL client factory",
    "function createSqlClient(env: Env): SqlClient {",
    "  // In dev, we use postgres via DATABASE_URL",
    "  // In production, this would use D1 or Hyperdrive",
    "  const client = async <T = unknown>(",
    "    strings: TemplateStringsArray,",
    "    ...values: unknown[]",
    "  ): Promise<T[]> => {",
    "    let query = ''",
    "    for (let i = 0; i < strings.length; i++) {",
    "      query += strings[i]",
    "      if (i < values.length) query += `$${i + 1}`",
    "    }",
    "    console.log('[SQL]', query, values)",
    "    // TODO: Implement actual postgres connection",
    "    return []",
    "  }",
    "",
    "  client.unsafe = async <T = unknown>(query: string): Promise<T[]> => {",
    "    console.log('[SQL unsafe]', query)",
    "    return []",
    "  }",
    "",
    "  return client",
    "}",
    "",
  ]

  // Source runner function (only if we have sources)
  if (enabledSources.length > 0) {
    code.push(
      "// Run a source and insert results",
      "async function runSource<T>(",
      "  name: string,",
      "  source: { fetch: (ctx: SourceContext<any>) => AsyncGenerator<T[]> },",
      "  env: Env,",
      "  ctx: ExecutionContext,",
      "  tableName: string",
      ") {",
      "  console.log(`[${name}] Starting sync...`)",
      "",
      "  const cursorKey = `cursor:${name}`",
      "  const cursor = await env.KV?.get(cursorKey) ?? null",
      "",
      "  const context: SourceContext<any> = {",
      "    secrets: env as any,",
      "    cursor,",
      "    setCursor: (c: string) => {",
      "      if (env.KV) ctx.waitUntil(env.KV.put(cursorKey, c))",
      "    },",
      "    sql: createSqlClient(env),",
      "    log: (...args: unknown[]) => console.log(`[${name}]`, ...args),",
      "  }",
      "",
      "  let total = 0",
      "  try {",
      "    for await (const batch of source.fetch(context)) {",
      "      // TODO: Insert batch into table",
      "      console.log(`[${name}] Batch of ${batch.length} records for ${tableName}`)",
      "      total += batch.length",
      "    }",
      "    console.log(`[${name}] Sync complete: ${total} records`)",
      "  } catch (error) {",
      "    console.error(`[${name}] Sync failed:`, error)",
      "    throw error",
      "  }",
      "}",
      "",
    )
  }

  // Worker export
  code.push(
    "// Worker export",
    "export default {",
    "  fetch: app.fetch,",
    "",
  )

  // Scheduled handler (only if we have sources)
  if (cronMap.size > 0) {
    code.push(
      "  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {",
      "    console.log(`[scheduled] Cron triggered: ${event.cron}`)",
      "",
      "    switch (event.cron) {",
    )

    for (const [cron, sources] of cronMap) {
      code.push(`      case "${cron}":`)
      for (const source of sources) {
        const varName = sanitizeName(source)
        const table = sourceToTable.get(source)!
        code.push(`        await runSource("${source}", ${varName}, env, ctx, "${table}")`)
      }
      code.push("        break")
      code.push("")
    }

    code.push(
      "      default:",
      '        console.warn(`[scheduled] Unknown cron: ${event.cron}`)',
      "    }",
      "  },",
    )
  }

  code.push("}")
  code.push("")

  return code.join("\n")
}

/**
 * Sanitize source name for use as JS variable
 */
function sanitizeName(name: string): string {
  return name.replace(/[^a-zA-Z0-9]/g, "_")
}
