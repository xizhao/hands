---
title: Scheduled Jobs
description: "Automate tasks with cron schedules"
---

# Scheduled Jobs

Scheduled jobs (also called monitors) run automatically on a schedule. Use them for data pipelines, reports, cleanup tasks, and more.

## Creating a Job

Ask the AI:

```
Create a job that refreshes the analytics every hour

Run a daily cleanup of old records

Send a weekly report email every Monday
```

## Job Structure

Jobs are defined in `monitors/`:

```typescript
// monitors/daily-stats.ts
import { monitor } from "@hands/stdlib";

export const handler = monitor(async (ctx) => {
  // Refresh materialized views
  await ctx.sql`REFRESH MATERIALIZED VIEW daily_stats`;

  // Log activity
  await ctx.log("Daily stats refreshed");

  // Return status
  return { status: "ok" };
});
```

## Configuration

Register jobs in `hands.config.ts`:

```typescript
export default defineConfig({
  monitors: {
    "daily-stats": {
      schedule: "cron(0 2 * * *)",  // 2 AM daily
      handler: "monitors/daily-stats.handler",
      timeout: 60,
      memory: 512
    },

    "hourly-sync": {
      schedule: "rate(1 hour)",
      handler: "monitors/hourly-sync.handler"
    }
  }
});
```

## Schedule Formats

### Rate Expressions

```
rate(5 minutes)   # Every 5 minutes
rate(1 hour)      # Every hour
rate(6 hours)     # Every 6 hours
rate(1 day)       # Every day
```

### Cron Expressions

```
cron(0 * * * *)      # Every hour at minute 0
cron(0 2 * * *)      # Daily at 2 AM
cron(0 9 * * 1)      # Every Monday at 9 AM
cron(0 0 1 * *)      # First of every month
cron(*/15 * * * *)   # Every 15 minutes
```

Cron format: `minute hour day-of-month month day-of-week`

## Job Context

Every job receives a context object:

```typescript
export const handler = monitor(async (ctx) => {
  // SQL client
  const users = await ctx.sql`SELECT * FROM users`;

  // Logging
  ctx.log("Processing started");
  ctx.log("Found " + users.length + " users");

  // Environment variables
  const apiKey = ctx.env.API_KEY;

  // Return status
  return { status: "ok", processed: users.length };
});
```

## Return Status

Jobs must return a status:

```typescript
// Success
return { status: "ok" };

// Success with details
return { status: "ok", rows: 1000, duration: "2.5s" };

// Warning (job succeeded but with issues)
return { status: "warning", message: "Some records skipped" };

// Error
return { status: "error", message: "Database connection failed" };
```

## Common Patterns

### Data Pipeline

```typescript
export const handler = monitor(async (ctx) => {
  // Extract
  const rawData = await ctx.sql`
    SELECT * FROM raw_events
    WHERE processed = false
    LIMIT 1000
  `;

  // Transform
  const transformed = rawData.map(transformRow);

  // Load
  for (const row of transformed) {
    await ctx.sql`
      INSERT INTO processed_events ${ctx.sql(row)}
    `;
  }

  // Mark as processed
  await ctx.sql`
    UPDATE raw_events SET processed = true
    WHERE id IN (${rawData.map(r => r.id)})
  `;

  return { status: "ok", processed: rawData.length };
});
```

### Data Cleanup

```typescript
export const handler = monitor(async (ctx) => {
  // Delete old records
  const result = await ctx.sql`
    DELETE FROM audit_logs
    WHERE created_at < NOW() - INTERVAL '90 days'
  `;

  // Vacuum table
  await ctx.sql`VACUUM ANALYZE audit_logs`;

  return { status: "ok", deleted: result.count };
});
```

### External API Sync

```typescript
export const handler = monitor(async (ctx) => {
  // Fetch from external API
  const response = await fetch("https://api.example.com/data", {
    headers: { "Authorization": `Bearer ${ctx.env.API_KEY}` }
  });

  if (!response.ok) {
    return { status: "error", message: "API request failed" };
  }

  const data = await response.json();

  // Upsert into database
  for (const item of data) {
    await ctx.sql`
      INSERT INTO external_data (id, data, synced_at)
      VALUES (${item.id}, ${JSON.stringify(item)}, NOW())
      ON CONFLICT (id) DO UPDATE
      SET data = EXCLUDED.data, synced_at = NOW()
    `;
  }

  return { status: "ok", synced: data.length };
});
```

### Report Generation

```typescript
export const handler = monitor(async (ctx) => {
  // Generate weekly report
  const stats = await ctx.sql`
    SELECT
      COUNT(*) as total_orders,
      SUM(amount) as revenue,
      AVG(amount) as avg_order
    FROM orders
    WHERE created_at > NOW() - INTERVAL '7 days'
  `;

  // Save report
  await ctx.sql`
    INSERT INTO weekly_reports (week, data)
    VALUES (date_trunc('week', NOW()), ${JSON.stringify(stats)})
  `;

  ctx.log("Weekly report generated: $" + stats[0].revenue);

  return { status: "ok" };
});
```

## Monitoring Jobs

View job status in the Hands toolbar:

- See which jobs ran and when
- Check success/failure status
- View logs and return values

## Error Handling

```typescript
export const handler = monitor(async (ctx) => {
  try {
    await doRiskyOperation();
    return { status: "ok" };
  } catch (error) {
    ctx.log("Error: " + error.message);
    return {
      status: "error",
      message: error.message
    };
  }
});
```

## Wrangler Configuration

Jobs also require a cron trigger in `wrangler.toml`:

```toml
[triggers]
crons = ["0 * * * *", "0 2 * * *"]
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Deploy" icon="rocket" href="/deploy/cloudflare">
    Run your jobs in production
  </Card>
  <Card title="Stdlib Reference" icon="book" href="/stdlib/monitor">
    Full monitor API reference
  </Card>
</CardGroup>
