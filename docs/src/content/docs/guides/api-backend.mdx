---
title: "Guide: Building an API Backend"
description: Create a REST API with authentication and CRUD operations
---

import { Steps } from '@astrojs/starlight/components';

This guide shows you how to build a complete REST API backend with authentication, validation, and CRUD operations.

## What we'll build

A products API with:
- JWT authentication
- CRUD operations for products
- Search and filtering
- Input validation
- Error handling

## Step 1: Set up the database

Create the products table:

```sql
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  price NUMERIC(10,2) NOT NULL,
  category TEXT,
  stock INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE api_keys (
  id SERIAL PRIMARY KEY,
  key TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  last_used_at TIMESTAMP
);

-- Insert a test API key
INSERT INTO api_keys (key, name)
VALUES ('test-api-key-12345', 'Development Key');

-- Insert sample products
INSERT INTO products (name, description, price, category, stock) VALUES
  ('Widget Pro', 'Professional grade widget', 99.99, 'Widgets', 50),
  ('Gadget Max', 'Maximum power gadget', 149.99, 'Gadgets', 25),
  ('Tool Basic', 'Entry level tool', 29.99, 'Tools', 100);
```

## Step 2: Create the API structure

Set up the file structure:

```
src/api/
├── index.ts        # Main router
├── middleware/
│   ├── auth.ts     # Authentication
│   └── error.ts    # Error handling
├── routes/
│   └── products.ts # Product routes
└── utils/
    └── validate.ts # Validation helpers
```

## Step 3: Set up authentication middleware

```typescript
// src/api/middleware/auth.ts
import { Context, Next } from 'hono';
import { sql } from '@hands/stdlib';

export async function apiKeyAuth(c: Context, next: Next) {
  const authHeader = c.req.header('Authorization');

  if (!authHeader?.startsWith('Bearer ')) {
    return c.json({ error: 'Missing API key' }, 401);
  }

  const apiKey = authHeader.slice(7);

  // Validate API key
  const key = await sql`
    SELECT id, name FROM api_keys
    WHERE key = ${apiKey}
  `;

  if (key.length === 0) {
    return c.json({ error: 'Invalid API key' }, 401);
  }

  // Update last used timestamp
  await sql`
    UPDATE api_keys SET last_used_at = NOW()
    WHERE id = ${key[0].id}
  `;

  // Attach key info to context
  c.set('apiKey', key[0]);

  await next();
}
```

## Step 4: Set up error handling middleware

```typescript
// src/api/middleware/error.ts
import { Context } from 'hono';
import { HTTPException } from 'hono/http-exception';

export function errorHandler(err: Error, c: Context) {
  console.error('API Error:', err);

  if (err instanceof HTTPException) {
    return c.json(
      { error: err.message },
      err.status
    );
  }

  // Database errors
  if (err.message.includes('unique constraint')) {
    return c.json(
      { error: 'Resource already exists' },
      409
    );
  }

  if (err.message.includes('foreign key')) {
    return c.json(
      { error: 'Referenced resource not found' },
      400
    );
  }

  // Generic error
  return c.json(
    { error: 'Internal server error' },
    500
  );
}
```

## Step 5: Create validation utilities

```typescript
// src/api/utils/validate.ts
import { z } from 'zod';

export const productSchema = z.object({
  name: z.string().min(1).max(255),
  description: z.string().optional(),
  price: z.number().positive(),
  category: z.string().optional(),
  stock: z.number().int().min(0).optional()
});

export const productUpdateSchema = productSchema.partial();

export const querySchema = z.object({
  search: z.string().optional(),
  category: z.string().optional(),
  minPrice: z.coerce.number().optional(),
  maxPrice: z.coerce.number().optional(),
  limit: z.coerce.number().int().min(1).max(100).default(20),
  offset: z.coerce.number().int().min(0).default(0)
});

export function validate<T>(schema: z.ZodSchema<T>, data: unknown): T {
  const result = schema.safeParse(data);
  if (!result.success) {
    const errors = result.error.errors.map(e =>
      `${e.path.join('.')}: ${e.message}`
    );
    throw new Error(`Validation failed: ${errors.join(', ')}`);
  }
  return result.data;
}
```

## Step 6: Create product routes

```typescript
// src/api/routes/products.ts
import { Hono } from 'hono';
import { HTTPException } from 'hono/http-exception';
import { sql } from '@hands/stdlib';
import {
  productSchema,
  productUpdateSchema,
  querySchema,
  validate
} from '../utils/validate';

const app = new Hono();

// List products with search and filtering
app.get('/', async (c) => {
  const query = validate(querySchema, c.req.query());

  let conditions = ['1=1'];
  let params: any[] = [];
  let paramIndex = 1;

  if (query.search) {
    conditions.push(`(name ILIKE $${paramIndex} OR description ILIKE $${paramIndex})`);
    params.push(`%${query.search}%`);
    paramIndex++;
  }

  if (query.category) {
    conditions.push(`category = $${paramIndex}`);
    params.push(query.category);
    paramIndex++;
  }

  if (query.minPrice !== undefined) {
    conditions.push(`price >= $${paramIndex}`);
    params.push(query.minPrice);
    paramIndex++;
  }

  if (query.maxPrice !== undefined) {
    conditions.push(`price <= $${paramIndex}`);
    params.push(query.maxPrice);
    paramIndex++;
  }

  const products = await sql`
    SELECT * FROM products
    WHERE ${sql.raw(conditions.join(' AND '))}
    ORDER BY created_at DESC
    LIMIT ${query.limit}
    OFFSET ${query.offset}
  `;

  const count = await sql`
    SELECT COUNT(*) as total FROM products
    WHERE ${sql.raw(conditions.join(' AND '))}
  `;

  return c.json({
    data: products,
    pagination: {
      total: parseInt(count[0].total),
      limit: query.limit,
      offset: query.offset
    }
  });
});

// Get single product
app.get('/:id', async (c) => {
  const id = parseInt(c.req.param('id'));

  const product = await sql`
    SELECT * FROM products WHERE id = ${id}
  `;

  if (product.length === 0) {
    throw new HTTPException(404, { message: 'Product not found' });
  }

  return c.json(product[0]);
});

// Create product
app.post('/', async (c) => {
  const body = await c.req.json();
  const data = validate(productSchema, body);

  const product = await sql`
    INSERT INTO products (name, description, price, category, stock)
    VALUES (${data.name}, ${data.description}, ${data.price}, ${data.category}, ${data.stock || 0})
    RETURNING *
  `;

  return c.json(product[0], 201);
});

// Update product
app.patch('/:id', async (c) => {
  const id = parseInt(c.req.param('id'));
  const body = await c.req.json();
  const data = validate(productUpdateSchema, body);

  // Check exists
  const existing = await sql`SELECT id FROM products WHERE id = ${id}`;
  if (existing.length === 0) {
    throw new HTTPException(404, { message: 'Product not found' });
  }

  // Build update
  const updates: string[] = [];
  const values: any[] = [];

  if (data.name !== undefined) {
    updates.push('name = $' + (values.length + 1));
    values.push(data.name);
  }
  if (data.description !== undefined) {
    updates.push('description = $' + (values.length + 1));
    values.push(data.description);
  }
  if (data.price !== undefined) {
    updates.push('price = $' + (values.length + 1));
    values.push(data.price);
  }
  if (data.category !== undefined) {
    updates.push('category = $' + (values.length + 1));
    values.push(data.category);
  }
  if (data.stock !== undefined) {
    updates.push('stock = $' + (values.length + 1));
    values.push(data.stock);
  }

  updates.push('updated_at = NOW()');

  const product = await sql`
    UPDATE products
    SET ${sql.raw(updates.join(', '))}
    WHERE id = ${id}
    RETURNING *
  `;

  return c.json(product[0]);
});

// Delete product
app.delete('/:id', async (c) => {
  const id = parseInt(c.req.param('id'));

  const result = await sql`
    DELETE FROM products WHERE id = ${id} RETURNING id
  `;

  if (result.length === 0) {
    throw new HTTPException(404, { message: 'Product not found' });
  }

  return c.json({ deleted: true });
});

export default app;
```

## Step 7: Create the main router

```typescript
// src/api/index.ts
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { logger } from 'hono/logger';
import { apiKeyAuth } from './middleware/auth';
import { errorHandler } from './middleware/error';
import products from './routes/products';

const app = new Hono();

// Global middleware
app.use('/*', cors());
app.use('/*', logger());

// Health check (no auth)
app.get('/health', (c) => c.json({ status: 'ok' }));

// Protected routes
app.use('/products/*', apiKeyAuth);
app.route('/products', products);

// Error handler
app.onError(errorHandler);

// 404 handler
app.notFound((c) => {
  return c.json({ error: 'Not found' }, 404);
});

export default app;
```

## Step 8: Test the API

Test locally with curl:

```bash
# Health check
curl http://localhost:8787/health

# List products (requires auth)
curl http://localhost:8787/products \
  -H "Authorization: Bearer test-api-key-12345"

# Search products
curl "http://localhost:8787/products?search=widget&category=Widgets" \
  -H "Authorization: Bearer test-api-key-12345"

# Create product
curl -X POST http://localhost:8787/products \
  -H "Authorization: Bearer test-api-key-12345" \
  -H "Content-Type: application/json" \
  -d '{"name": "New Product", "price": 49.99}'

# Update product
curl -X PATCH http://localhost:8787/products/1 \
  -H "Authorization: Bearer test-api-key-12345" \
  -H "Content-Type: application/json" \
  -d '{"price": 59.99}'

# Delete product
curl -X DELETE http://localhost:8787/products/1 \
  -H "Authorization: Bearer test-api-key-12345"
```

## Step 9: Deploy

<Steps>
1. Click **Deploy** to push to Cloudflare Workers
2. Your API is live at `https://your-app.workers.dev`
3. Update your frontend to use the new URL
</Steps>

## Adding more features

### Rate limiting

```typescript
import { rateLimiter } from 'hono/rate-limiter';

app.use('/products/*', rateLimiter({
  windowMs: 60 * 1000, // 1 minute
  limit: 100,          // 100 requests per window
}));
```

### Response caching

```typescript
app.get('/products', async (c) => {
  c.header('Cache-Control', 'public, max-age=60');
  // ... rest of handler
});
```

### OpenAPI documentation

```typescript
import { swaggerUI } from '@hono/swagger-ui';

app.get('/docs', swaggerUI({ url: '/openapi.json' }));
```

## Next steps

- Add [Scheduled jobs](/apps/scheduled-jobs/) for data processing
- Build [Dashboards](/apps/dashboards/) for API analytics
- Learn about [Deployment configuration](/deploy/configuration/)
