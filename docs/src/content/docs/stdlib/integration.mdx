---
title: Integration
description: Connect to external databases and services
---

The `integration` function creates connections to external data sources.

## Basic usage

```typescript
import { integration } from '@hands/stdlib';

const external = integration({
  type: 'postgres',
  connectionString: process.env.DATABASE_URL
});

const users = await external.query('SELECT * FROM users');
```

## Supported types

### PostgreSQL

```typescript
const pg = integration({
  type: 'postgres',
  connectionString: 'postgresql://user:pass@host:5432/db'
});

// Or with individual options
const pg = integration({
  type: 'postgres',
  host: 'db.example.com',
  port: 5432,
  database: 'mydb',
  user: 'user',
  password: process.env.DB_PASSWORD,
  ssl: true
});
```

### MySQL

```typescript
const mysql = integration({
  type: 'mysql',
  connectionString: 'mysql://user:pass@host:3306/db'
});
```

### SQLite

```typescript
const sqlite = integration({
  type: 'sqlite',
  path: './data/external.db'
});
```

### HTTP API

```typescript
const api = integration({
  type: 'http',
  baseUrl: 'https://api.example.com',
  headers: {
    'Authorization': `Bearer ${process.env.API_KEY}`
  }
});
```

## Querying

### SQL databases

```typescript
// Simple query
const users = await external.query('SELECT * FROM users');

// With parameters
const user = await external.query(
  'SELECT * FROM users WHERE id = $1',
  [userId]
);

// Multiple statements
const results = await external.query(`
  SELECT COUNT(*) as total FROM orders;
  SELECT SUM(amount) as revenue FROM orders;
`);
```

### HTTP APIs

```typescript
// GET request
const data = await api.get('/users');

// POST request
const result = await api.post('/users', {
  name: 'John',
  email: 'john@example.com'
});

// With query parameters
const filtered = await api.get('/users', {
  params: { status: 'active', limit: 10 }
});
```

## Syncing data

### One-time import

```typescript
import { sql, integration } from '@hands/stdlib';

const external = integration({
  type: 'postgres',
  connectionString: process.env.EXTERNAL_DB
});

export async function importUsers() {
  const users = await external.query('SELECT * FROM users');

  for (const user of users) {
    await sql`
      INSERT INTO users (id, name, email, created_at)
      VALUES (${user.id}, ${user.name}, ${user.email}, ${user.created_at})
      ON CONFLICT (id) DO UPDATE SET
        name = EXCLUDED.name,
        email = EXCLUDED.email
    `;
  }
}
```

### Incremental sync

```typescript
export async function incrementalSync() {
  // Get last sync timestamp
  const lastSync = await sql`
    SELECT MAX(synced_at) as last FROM users
  `;

  // Fetch only new/updated records
  const newUsers = await external.query(
    'SELECT * FROM users WHERE updated_at > $1',
    [lastSync[0].last || '1970-01-01']
  );

  // Upsert records
  for (const user of newUsers) {
    await sql`
      INSERT INTO users (id, name, email, synced_at)
      VALUES (${user.id}, ${user.name}, ${user.email}, NOW())
      ON CONFLICT (id) DO UPDATE SET
        name = EXCLUDED.name,
        email = EXCLUDED.email,
        synced_at = NOW()
    `;
  }

  return newUsers.length;
}
```

### Scheduled sync

```typescript
// hands.config.ts
export default defineConfig({
  triggers: {
    scheduled: [
      {
        cron: '*/15 * * * *',
        handler: './src/jobs/sync.ts'
      }
    ]
  }
});

// src/jobs/sync.ts
import { sql, integration } from '@hands/stdlib';

const external = integration({
  type: 'postgres',
  connectionString: process.env.EXTERNAL_DB
});

export default async function() {
  const count = await incrementalSync();
  console.log(`Synced ${count} records`);
}
```

## Connection pooling

For high-throughput scenarios:

```typescript
const pg = integration({
  type: 'postgres',
  connectionString: process.env.DATABASE_URL,
  pool: {
    min: 2,
    max: 10,
    idleTimeout: 30000
  }
});
```

## Error handling

```typescript
try {
  const data = await external.query('SELECT * FROM users');
} catch (err) {
  if (err.code === 'ECONNREFUSED') {
    console.error('Cannot connect to database');
  } else if (err.code === '42P01') {
    console.error('Table does not exist');
  } else {
    throw err;
  }
}
```

## Transactions

```typescript
await external.transaction(async (tx) => {
  await tx.query('UPDATE accounts SET balance = balance - 100 WHERE id = $1', [fromId]);
  await tx.query('UPDATE accounts SET balance = balance + 100 WHERE id = $1', [toId]);
});
```

## Multiple integrations

```typescript
const orders = integration({
  type: 'postgres',
  connectionString: process.env.ORDERS_DB
});

const inventory = integration({
  type: 'mysql',
  connectionString: process.env.INVENTORY_DB
});

const analytics = integration({
  type: 'http',
  baseUrl: 'https://analytics.example.com'
});

export async function syncAll() {
  const orderData = await orders.query('SELECT * FROM orders');
  const stockData = await inventory.query('SELECT * FROM stock');
  await analytics.post('/events', { orders: orderData.length });
}
```

## Security

### Environment variables

Always use environment variables for credentials:

```typescript
// Good
const db = integration({
  type: 'postgres',
  connectionString: process.env.DATABASE_URL
});

// Bad - never hardcode credentials
const db = integration({
  type: 'postgres',
  connectionString: 'postgresql://user:password@host/db'
});
```

### SSL connections

```typescript
const db = integration({
  type: 'postgres',
  connectionString: process.env.DATABASE_URL,
  ssl: {
    rejectUnauthorized: true,
    ca: process.env.CA_CERT
  }
});
```

## Reference

### integration(config)

Create an integration connection.

```typescript
integration({
  type: 'postgres' | 'mysql' | 'sqlite' | 'http',

  // For SQL databases
  connectionString?: string,
  host?: string,
  port?: number,
  database?: string,
  user?: string,
  password?: string,
  ssl?: boolean | SSLConfig,
  pool?: PoolConfig,

  // For HTTP
  baseUrl?: string,
  headers?: Record<string, string>,
  timeout?: number
})
```

### Methods

```typescript
// SQL databases
integration.query(sql: string, params?: any[]): Promise<any[]>
integration.transaction(fn: (tx) => Promise<void>): Promise<void>

// HTTP
integration.get(path: string, options?: RequestOptions): Promise<any>
integration.post(path: string, body?: any, options?: RequestOptions): Promise<any>
integration.put(path: string, body?: any, options?: RequestOptions): Promise<any>
integration.delete(path: string, options?: RequestOptions): Promise<any>
```
